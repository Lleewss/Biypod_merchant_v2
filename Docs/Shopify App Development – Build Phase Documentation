# Shopify App Development – Build Phase Documentation

## Getting Started with Shopify App Development

### Build (Overview of the Shopify App Platform)

**“Build”** is the main landing page for Shopify app development. It emphasizes that Shopify apps **augment core commerce functionality** by combining ready-made building blocks into novel solutions[\[1\]](http://shopify.dev/docs/apps/build#:~:text=Apps%20to%20power%20commerce). Apps can **integrate into many Shopify surfaces** – admin, online store, checkout, etc. – allowing merchants to extend Shopify’s capabilities[\[2\]](http://shopify.dev/docs/apps/build#:~:text=Where%20you%20can%20build). Shopify provides ~80% of merchant needs out-of-the-box, and apps fill the remaining gaps, solving specific merchant problems (often in ways the core platform does not)[\[3\]](http://shopify.dev/docs/apps/build#:~:text=Shopify%20itself%20meets%20about%2080,Shopify%20merchants%20turn%20to%20apps). The Build page also links to best practices (accessibility, performance, etc.) and guidance on app quality and deployment[\[4\]\[5\]](http://shopify.dev/docs/apps/build#:~:text=). In short, it introduces the app platform’s **breadth of integration points** and encourages developers to build high-quality apps that meet merchant needs beyond Shopify’s native features.

### App Surfaces (Where Apps Appear in Shopify)

**“App surfaces”** refer to the areas of Shopify’s platform where an app can appear and add functionality. A single app can extend multiple areas of Shopify – such as the Shopify admin, checkout, online store, Shopify Flow, or Shopify POS[\[6\]](http://shopify.dev/docs/apps/build/app-surfaces#:~:text=Shopify%20apps%20can%20appear%20in,to%20arrange%20for%20hosting%20yourself). Shopify provides different **extension mechanisms** for each surface. For example, in the **Shopify admin**, apps can embed pages inside the admin, add custom data via metafields/metaobjects, or inject UI through app extensions[\[7\]](http://shopify.dev/docs/apps/build/app-surfaces#:~:text=The%20Shopify%20admin%20is%20the,admin%20using%20the%20following%20technologies). In **Checkout**, apps can inject UI elements or logic via Checkout UI Extensions and Functions. In the **Online store**, apps might use theme app extensions or proxies to render dynamic content. Each surface has corresponding tools (App Bridge and Polaris for admin embedded pages, extension APIs, GraphQL APIs, etc.) to ensure the app feels native to that context[\[8\]](http://shopify.dev/docs/apps/build/app-surfaces#:~:text=Anchor%20to%20Embedded%20app%20pagesEmbedded,app%20pages)[\[9\]](http://shopify.dev/docs/apps/build/app-surfaces#:~:text=Anchor%20to%20Custom%20dataCustom%20data). The App Surfaces guide provides an overview of these integration points and notes that regardless of where an app surfaces, you’ll need a Partner account and development store for testing[\[10\]](http://shopify.dev/docs/apps/build/app-surfaces#:~:text=Note).

### Scaffold an App (Initial Project Setup)

**“Scaffold an app”** is a tutorial that walks you through creating a new Shopify app project. It covers setting up your development environment and using the **Shopify CLI** to generate a starter app template[\[11\]](http://shopify.dev/docs/apps/build/scaffold-app#:~:text=You%27re%20ready%20to%20scaffold%20a,that%20you%20can%20start%20coding). In this tutorial, you create a simple embedded app (for example, a product QR code generator app) that appears in the Shopify admin[\[12\]](http://shopify.dev/docs/apps/build/scaffold-app#:~:text=In%20this%20tutorial%2C%20you%27ll%20scaffold,CLI%20to%20develop%20your%20app). The guide shows how to run shopify app init to create a new app project and then run shopify app dev to start a local development server. Shopify CLI handles tasks like creating a **tunnel** (via Cloudflare) and registering your app with your Partner account, so you can immediately install the app on a dev store and see it running in the admin[\[13\]](http://shopify.dev/docs/apps/build/scaffold-app#:~:text=Shopify%20CLI%20performs%20the%20following,tasks). By following _Scaffold an app_, a developer ends up with a working app running locally and embedded in Shopify, which they can then modify. Key things you learn include initializing a Remix-based app with shopify app init (choosing the **Remix** template) and granting any required access scopes (the tutorial suggests the app needs write_products to generate a product for testing)[\[14\]](http://shopify.dev/docs/apps/build/scaffold-app#:~:text=shopify%20app%20init)[\[15\]](http://shopify.dev/docs/apps/build/scaffold-app#:~:text=store%20). Overall, _Scaffold an app_ helps you **set up the app structure and development server** so you can start coding your app’s features[\[16\]](http://shopify.dev/docs/apps/build/scaffold-app#:~:text=,product%20using%20your%20new%20app)[\[17\]](http://shopify.dev/docs/apps/build/scaffold-app#:~:text=Anchor%20to%20Step%201%3A%20Create,1%3A%20Create%20a%20new%20app).

### Shopify Dev MCP Server (AI Assistant for Devs)

The **Shopify Dev MCP server** is a tool for connecting an AI development assistant (like Cursor or OpenAI ChatGPT via specific IDE plugins) to Shopify’s developer resources. “MCP” stands for _Model Context Protocol_. By running the Dev MCP server locally, an AI assistant can gain read-access to Shopify’s documentation, API schemas, and even sample code, allowing it to answer coding questions and assist in building Shopify apps[\[18\]](http://shopify.dev/docs/apps/build/devmcp#:~:text=Connect%20your%20AI%20assistant%20to,date%20answers%20about%20Shopify%20APIs)[\[19\]](http://shopify.dev/docs/apps/build/devmcp#:~:text=Your%20AI%20assistant%20uses%20the,interact%20with%20Shopify%27s%20development%20resources). For example, once set up, you could ask your AI tool _“How do I create a product using the Admin API?”_ or _“Show me an example webhook subscription”_, and the AI (via the MCP server) will search official docs/schemas to help provide the answer[\[20\]](http://shopify.dev/docs/apps/build/devmcp#:~:text=Anchor%20to%20What%20you%20can,can%20ask%20your%20AI%20assistant)[\[21\]](http://shopify.dev/docs/apps/build/devmcp#:~:text=Your%20AI%20assistant%20will%20use,Shopify%27s%20documentation%20when%20providing%20responses). The guide shows how to run the server with npx @shopify/dev-mcp@latest and configure your AI tool to use it[\[22\]](http://shopify.dev/docs/apps/build/devmcp#:~:text=Anchor%20to%20Step%201%3A%20Run,serverStep%201%3A%20Run%20the%20server)[\[23\]](http://shopify.dev/docs/apps/build/devmcp#:~:text=Add%20configuration%20code%20that%20tells,guidance%20when%20you%20ask%20questions). It also lists supported API domains (Admin API, Functions, etc.) and stresses that since the server runs locally with no auth required, it’s a dev tool (not to be exposed publicly)[\[24\]](http://shopify.dev/docs/apps/build/devmcp#:~:text=The%20MCP%20server%20provides%20tools,with%20the%20following%20Shopify%20APIs)[\[25\]](http://shopify.dev/docs/apps/build/devmcp#:~:text=The%20server%20runs%20locally%20in,environment%20and%20doesn%27t%20require%20authentication). In short, the Dev MCP server is a **productivity utility** enabling AI-powered coding assistance that’s aware of Shopify’s API and docs, helping developers build apps more efficiently with accurate, up-to-date Shopify guidance[\[18\]](http://shopify.dev/docs/apps/build/devmcp#:~:text=Connect%20your%20AI%20assistant%20to,date%20answers%20about%20Shopify%20APIs)[\[19\]](http://shopify.dev/docs/apps/build/devmcp#:~:text=Your%20AI%20assistant%20uses%20the,interact%20with%20Shopify%27s%20development%20resources).

### Build a Shopify App Using Remix (Tutorial)

This is an in-depth tutorial that builds on a scaffolded Remix app to create a functional Shopify app (in the example, an app that generates **QR codes for products**). The **“Build a Shopify app using Remix”** guide teaches how to add features to the scaffolded app, including: setting up a database model (QRCode model via Prisma) to store app data, using the @shopify/shopify-app-remix package for authentication and GraphQL queries, using Polaris React components to build UI that matches Shopify’s design, and using App Bridge for interactive behavior[\[26\]](http://shopify.dev/docs/apps/build/build?framework=remix#:~:text=In%20this%20tutorial%2C%20you%27ll%20learn,to%20do%20the%20following%20tasks). For instance, you add a new table for QR codes to the SQLite DB and run a migration[\[27\]](http://shopify.dev/docs/apps/build/build?framework=remix#:~:text=Anchor%20to%20Create%20the%20tableCreate,the%20table)[\[28\]](http://shopify.dev/docs/apps/build/build?framework=remix#:~:text=1,create%20the%20table%20in%20Prisma), then build out UI pages where merchants can create QR codes for products and track scans. The tutorial highlights key tasks like updating the Prisma schema, authenticating and querying Shopify data (to fetch product info), and logging scan events[\[29\]](http://shopify.dev/docs/apps/build/build?framework=remix#:~:text=In%20this%20tutorial%2C%20you%27ll%20scaffold,metrics%20to%20the%20app%20user)[\[30\]](http://shopify.dev/docs/apps/build/build?framework=remix#:~:text=,add%20interactivity%20to%20your%20app). Essentially, it walks through the full cycle of building a **real app feature** – from backend (model & migration) to frontend (UI components) – using modern Remix and Shopify libraries. It’s a comprehensive guide to building an embedded app with Remix, Polaris, and App Bridge, culminating in a working app that merchants can use to generate QR codes and view scan metrics[\[31\]](http://shopify.dev/docs/apps/build/build?framework=remix#:~:text=After%20you%20scaffold%20an%20app%2C,outside%20of%20the%20Shopify%20admin)[\[26\]](http://shopify.dev/docs/apps/build/build?framework=remix#:~:text=In%20this%20tutorial%2C%20you%27ll%20learn,to%20do%20the%20following%20tasks).

## Shopify CLI for Apps (Development Tooling)

### About Shopify CLI for Apps

**Shopify CLI** is a cornerstone tool for app development. It’s a command-line interface that helps you **scaffold apps and app extensions**, run your app locally, and automate common tasks[\[32\]](https://shopify.dev/docs/apps/build/cli-for-apps#:~:text=About%20Shopify%20CLI%20for%20apps). The CLI can generate new app projects (Node/Remix, Ruby on Rails, etc.), create extension code (for checkout UI, admin UI, etc.), **build and preview** your app on a dev store via an ngrok/Cloudflare tunnel, and deploy extensions. In short, it streamlines the dev workflow[\[33\]](https://shopify.dev/docs/apps/build/cli-for-apps#:~:text=Shopify%20CLI%20accelerates%20your%20app,process%20with%20the%20following%20features). The documentation for CLI highlights features such as quickly creating new apps from templates, generating app extensions, creating app entries in your Partner Dashboard automatically, spinning up local preview servers, and handling deployment of app config and extensions[\[33\]](https://shopify.dev/docs/apps/build/cli-for-apps#:~:text=Shopify%20CLI%20accelerates%20your%20app,process%20with%20the%20following%20features). It also notes that CLI is not just for apps; it also has modes for theme and Hydrogen storefront development (but those are covered elsewhere)[\[34\]](https://shopify.dev/docs/apps/build/cli-for-apps#:~:text=it%20to%20automate%20many%20common,development%20tasks). Using Shopify CLI is **highly recommended** for app dev, as it provides a consistent project structure and integrates with Shopify’s infrastructure (e.g., tunneling and updating app records)[\[35\]](https://shopify.dev/docs/apps/build/cli-for-apps#:~:text=To%20offer%20a%20better%20and,app%27s%20dependencies%20in%20one%20place). Overall, _About Shopify CLI_ underscores that CLI v3.x is the primary tool to create and manage app projects efficiently[\[32\]](https://shopify.dev/docs/apps/build/cli-for-apps#:~:text=About%20Shopify%20CLI%20for%20apps)[\[33\]](https://shopify.dev/docs/apps/build/cli-for-apps#:~:text=Shopify%20CLI%20accelerates%20your%20app,process%20with%20the%20following%20features).

### App Structure (Directory Layout for CLI Projects)

Apps created with Shopify CLI follow a standardized directory structure[\[36\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-structure#:~:text=All%20apps%20created%20with%20Shopify,depending%20on%20your%20app%27s%20functionality). The **App Structure** guide breaks down this layout. Key elements include: a root shopify.app.toml file (metadata and configuration for the app)[\[37\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-structure#:~:text=File%2Fdirectory%20Required%3FDescription%20shopify,project%20structure%20or%20template%2C%20you), an app/ directory containing your web backend and frontend code (for example, a Remix app’s routes and entry points)[\[38\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-structure#:~:text=Web%20files%20directory%20No%20The,such%20as%20a%20responsive%20layout), and an extensions/ directory for any app extensions (each extension in its own subfolder with its own shopify.extension.toml and source code)[\[39\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-structure#:~:text=,the%20name%20of%20the%20directory). There may also be additional config files like shopify.app.dev.toml for different environments, a package.json for Node dependencies, and an .env file for environment variables[\[37\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-structure#:~:text=File%2Fdirectory%20Required%3FDescription%20shopify,project%20structure%20or%20template%2C%20you)[\[39\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-structure#:~:text=,the%20name%20of%20the%20directory). The doc provides a tree diagram of the file structure and explains each piece – for instance, the example shows extensions/ containing subfolders for a UI extension, a Function extension, a theme extension, etc., each with their own config and code files[\[40\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-structure#:~:text=%E2%94%94%E2%94%80%E2%94%80%20)[\[41\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-structure#:~:text=%E2%94%9C%E2%94%80%E2%94%80%20extensions%2F). This **conventional structure** allows CLI to serve both the app and extensions together, and helps manage all dependencies in one place[\[42\]](https://shopify.dev/docs/apps/build/cli-for-apps#:~:text=Anchor%20to%20App%20structureApp%20structure). In summary, the App Structure documentation ensures you understand where to put your code and config in a CLI-generated app, so you can easily serve and deploy your app and its extensions from a unified project[\[36\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-structure#:~:text=All%20apps%20created%20with%20Shopify,depending%20on%20your%20app%27s%20functionality)[\[38\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-structure#:~:text=Web%20files%20directory%20No%20The,such%20as%20a%20responsive%20layout).

### App Configuration (Using TOML Config Files)

**App configuration** files (shopify.app.toml and friends) let you define your app’s settings (like embedded vs. standalone, OAuth redirect URLs, required access scopes, etc.) in code. The **App Configuration** guide explains that you can configure most app settings locally in these TOML files, then sync them to your app’s record on Shopify via CLI deploy commands[\[43\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-configuration#:~:text=You%20can%20configure%20your%20apps,active%20version%20of%20your%20app). This approach (Infrastructure as Code) means you can version-control your app’s configuration. For example, you might specify your app’s name, embedded status, OAuth callback URLs, and requested API scopes in shopify.app.toml, and those will be applied when you run shopify app deploy[\[43\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-configuration#:~:text=You%20can%20configure%20your%20apps,active%20version%20of%20your%20app)[\[44\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-configuration#:~:text=Note). One important note is that after editing config files, you need to run the CLI deploy to push changes – the guide cautions that the older command shopify app config push is deprecated, and the new process is to use shopify app deploy[\[44\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-configuration#:~:text=Note). In summary, _App Configuration_ emphasizes managing app settings through code for consistency, and it describes how Shopify CLI ties the local config to the Partner Dashboard app settings. Any changes to these files require deployment to take effect, ensuring the **source of truth** for your app’s setup can live in your repository[\[43\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-configuration#:~:text=You%20can%20configure%20your%20apps,active%20version%20of%20your%20app)[\[45\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-configuration#:~:text=The%20,command).

### Manage App Configuration Files (CLI Tutorial)

This tutorial shows how to use Shopify CLI to manage and test different app configuration files – for instance, linking multiple **configurations** for dev, staging, and production. The guide covers using the CLI to create or link an app to config files (via shopify app config link) and how to use multiple shopify.app.{name}.toml files for separate environments[\[46\]](https://shopify.dev/docs/apps/build/cli-for-apps/manage-app-config-files#:~:text=Anchor%20to%20Link%20and%20configure,appsLink%20and%20configure%20apps)[\[47\]](https://shopify.dev/docs/apps/build/cli-for-apps/manage-app-config-files#:~:text=After%20your%20app%20has%20been,development%2C%20staging%2C%20and%20production%20workflows). It explains that you can have, say, a shopify.app.dev.toml and shopify.app.prod.toml to correspond to different app instances (one installed on a dev store, another on a live store). The CLI allows you to switch which config is active with shopify app config use or by passing --config flags when running commands[\[48\]](https://shopify.dev/docs/apps/build/cli-for-apps/manage-app-config-files#:~:text=You%20don%E2%80%99t%20need%20to%20commit,s%29%20to%20your%20repository). This enables safe testing – you might dedicate a separate “staging” app in your Partners Dashboard with its own config file, so you don’t disrupt the production app while iterating on changes[\[49\]](https://shopify.dev/docs/apps/build/cli-for-apps/manage-app-config-files#:~:text=Anchor%20to%20Test%20your%20app,functionalityTest%20your%20app%20functionality)[\[50\]](https://shopify.dev/docs/apps/build/cli-for-apps/manage-app-config-files#:~:text=Use%20,Learn%20more%20about%20configuration%20names). In short, _Manage app config files_ shows how to **link your local code to multiple app instances** and seamlessly deploy changes across them, supporting a typical dev->staging->prod workflow. It also demonstrates that after linking config files, deploying via CLI will push the changes to the respective app version on Shopify[\[51\]](https://shopify.dev/docs/apps/build/cli-for-apps/manage-app-config-files#:~:text=You%20can%20create%2C%20link%2C%20and,root%20directory%20of%20your%20app)[\[52\]](https://shopify.dev/docs/apps/build/cli-for-apps/manage-app-config-files#:~:text=shopify%20app%20config%20link).

### Select a Networking Option for Local Development

When running your app with shopify app dev, Shopify CLI by default creates a Cloudflare tunnel to serve your app over HTTPS. The **“Select a networking option for local development”** guide explains alternatives to this default. You can choose between **Cloudflare Quick Tunnels (default)**, using **localhost (no tunnel)**, or using a **custom tunnel like ngrok** for your development environment[\[53\]](https://community.shopify.dev/t/allow-setting-port-for-shopify-app-dev-use-localhost/12798#:~:text=Select%20a%20networking%20option%20for,local%20development). Cloudflare quick tunnels are easiest (no setup, auto-HTTPS), but you might prefer localhost (for offline dev or if you want to use your own tunneling). The doc shows how to run CLI with flags like --use-localhost (which serves the app at <http://localhost> for dev, requiring you to manually create an HTTPS tunnel or only test on devices that can reach localhost)[\[53\]](https://community.shopify.dev/t/allow-setting-port-for-shopify-app-dev-use-localhost/12798#:~:text=Select%20a%20networking%20option%20for,local%20development). It also covers using the --tunnel-url flag if you have an external tunnel. Essentially, this guide helps you choose the networking method that fits your needs and describes how CLI can accommodate it, ensuring you can **preview your app** either via Shopify’s provided tunnel or your own setup. (For example, to avoid issues with hot reload, CLI v3.78+ added stable port support for --use-localhost mode as noted in the community forums[\[54\]](https://community.shopify.dev/t/allow-setting-port-for-shopify-app-dev-use-localhost/12798#:~:text=NickWesselman%20%20May%2019%2C%202025%2C,1%3A56pm%20%204)[\[55\]](https://community.shopify.dev/t/allow-setting-port-for-shopify-app-dev-use-localhost/12798#:~:text=FYI%20in%20the%20latest%20CLI,port%60%20argument).)

_In practice:_ if Cloudflare tunnels are blocked or you need a persistent URL, you might switch to your own ngrok, whereas if simplicity is key, you stick with the default. The main takeaway is that Shopify CLI offers flexibility in **how your dev app is exposed** during development, and this guide shows how to configure those options.

### Migrate from a Partner Dashboard-Managed App to CLI

This guide addresses migrating apps that were originally set up and configured entirely through the Partner Dashboard (legacy workflow) into the **Shopify CLI 3.x workflow**. It provides reasons to migrate: with CLI-managed apps, your app’s configuration is code-driven and version-controlled, you can use new features like extension development, and certain settings (like app “handles” for links) are only configurable via CLI now[\[56\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-from-dashboard#:~:text=If%20you%27ve%20been%20using%20the,instead%20for%20the%20following%20reasons). The migration process involves creating a new CLI project for your app and then importing the app’s existing configuration into code. The tutorial has you create an “extension-only” app scaffold (essentially an empty shell app) and then run shopify app config link to connect that project to your live app, pulling in settings like the app’s name, URL, and scopes into the shopify.app.toml[\[57\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-from-dashboard#:~:text=Anchor%20to%20Step%201%3A%20Create,1%3A%20Create%20a%20new%20app)[\[58\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-from-dashboard#:~:text=shopify%20app%20config%20link). After linking, you update any additional config and then run shopify app deploy to push the config to Shopify. From then on, instead of configuring via the Partner Dashboard UI, you will update the TOML file and deploy, which enforces consistency across environments[\[59\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-from-dashboard#:~:text=You%27ve%20successfully%20moved%20your%20app,app%20version%20to%20app%20users). Summarily, migrating ensures your app can leverage **CLI features and new app extension types**, and it consolidates app setup into your development workflow. The doc lists benefits like using Git for config changes and managing multiple envs in one codebase (e.g., one project linking both staging and production app IDs)[\[60\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-from-dashboard#:~:text=,in%20a%20single%20local%20project). The final step is that once migrated, you’ll manage app settings via code, and the old Dashboard settings become inactive, preventing drift between code and settings[\[59\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-from-dashboard#:~:text=You%27ve%20successfully%20moved%20your%20app,app%20version%20to%20app%20users).

### Migrate to Shopify CLI 3.x (from CLI v2 or no CLI)

If you have an app built with an older CLI (v1 or v2) or built manually, the **Migrate to Shopify CLI 3.x** guide helps you reorganize it to the new structure and configuration style. Shopify CLI 3.x introduced a **conventional directory structure and TOML config files**, as well as a Node-based runtime for the CLI itself[\[61\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-to-latest-cli#:~:text=To%20offer%20a%20better%20and,based%20dependencies%20for%20you)[\[62\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-to-latest-cli#:~:text=When%20you%20migrate%20your%20app,improvements%20to%20the%20developer%20experience). The migration involves moving code into the expected folders (for example, ensuring any existing extension code is under an extensions/ directory, creating shopify.app.toml and shopify.extension.toml files as needed) and possibly updating how environment-specific logic is handled. Key improvements with CLI 3.x include simplified config (using TOML instead of old YAML or other config, fewer files to manage) and unified deployment of app and extensions together[\[63\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-to-latest-cli#:~:text=Anchor%20to%20Simplified%20configuration%20filesSimplified,configuration%20files). The guide provides step-by-step instructions: create required CLI config files, adjust your project layout to match CLI’s expectations, and test that the CLI can now run and deploy your app[\[64\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-to-latest-cli#:~:text=If%20you%20have%20an%20app,how%20your%20app%20is%20organized)[\[65\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-to-latest-cli#:~:text=Shopify%20CLI%203,generate%20new%20app%20extensions%20easily). Essentially, migrating ensures your app can use the latest CLI features (like integrated extension management and simplified commands) and aligns with Shopify’s current developer tooling. The doc emphasizes Rust or JavaScript function projects need certain adjustments (like new build targets) and that after migration, you’ll manage your app and extensions in one project with the CLI handling build/deploy processes[\[61\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-to-latest-cli#:~:text=To%20offer%20a%20better%20and,based%20dependencies%20for%20you)[\[63\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-to-latest-cli#:~:text=Anchor%20to%20Simplified%20configuration%20filesSimplified,configuration%20files). By following this guide, developers can **modernize older apps** to the current best practices, resulting in more maintainable and integrated projects.

## Apps in the Shopify Admin (Back Office Integrations)

### Apps in Admin (Overview)

Shopify’s admin is the merchant’s back office, and **“Apps in admin”** describes how apps can integrate there to enhance merchant workflows. Apps can embed their own pages inside the admin (the **app home** or other embedded pages), and they can augment existing admin pages through **Admin UI Extensions**[\[66\]](https://shopify.dev/docs/apps/build/admin#:~:text=The%20primary%20place%20where%20users,to%20your%20app%20in%20Shopify)[\[67\]](https://shopify.dev/docs/apps/build/admin#:~:text=Anchor%20to%20UI%20extensions%20in,adminUI%20extensions%20in%20admin). The admin overview explains that an app’s primary interface is often its _app home_, which is loaded in an iframe or WebView within Shopify’s admin – by using Shopify App Bridge and Polaris design components, apps can make this embedded page feel native and interactive (e.g., opening modals, adding navigation items, etc.)[\[68\]](https://shopify.dev/docs/apps/build/admin#:~:text=navigation). Beyond full pages, apps can use UI extensions to insert functionality directly into Shopify’s own admin pages. The three main types of admin UI extensions are introduced here: **Admin actions** (extensions that appear in “More actions” menus or bulk action menus and open as modals), **Admin print actions** (a special case of actions under the “Print” menu for orders/products, allowing printing of documents), and **Admin blocks** (extensions that render as cards on pages like product or order details)[\[69\]](https://shopify.dev/docs/apps/build/admin#:~:text=To%20display%20a%20user%20interface,print%20actions%2C%20and%20admin%20blocks)[\[70\]](https://shopify.dev/docs/apps/build/admin#:~:text=Anchor%20to%20Admin%20print%20actionsAdmin,print%20actions). Each provides a way for the app to be present in context – for example, an admin action could let a merchant trigger a workflow from an order page, while an admin block might show loyalty points on a customer record[\[71\]](https://shopify.dev/docs/apps/build/admin#:~:text=Anchor%20to%20Admin%20actionsAdmin%20actions)[\[72\]](https://shopify.dev/docs/apps/build/admin#:~:text=Anchor%20to%20Admin%20blocksAdmin%20blocks). The admin overview also mentions **Admin link extensions** (simple links from admin resource pages to the app, now largely superseded by UI extensions)[\[73\]](https://shopify.dev/docs/apps/build/admin#:~:text=Anchor%20to%20Admin%20link%20extensionsAdmin,link%20extensions). In summary, _Apps in admin_ lays out that integrating with the admin gives merchants a familiar, convenient experience for using app features within their regular store management, and it enumerates the mechanisms (embedded pages, UI extensions, link extensions) available for doing so[\[74\]](https://shopify.dev/docs/apps/build/admin#:~:text=The%20Shopify%20admin%20is%20where,and%20can%20be%20easily%20found)[\[67\]](https://shopify.dev/docs/apps/build/admin#:~:text=Anchor%20to%20UI%20extensions%20in,adminUI%20extensions%20in%20admin).

### Admin UI Extensions (Overview of Actions & Blocks)

**Admin UI extensions** enable apps to seamlessly embed UI in Shopify admin pages using extension points called _actions_ and _blocks_. The _About admin UI extensions_ guide explains that these extensions automatically adopt Shopify’s look and feel, and allow merchants to use app features without leaving the current page[\[75\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=UI%20extensions%20enable%20you%20to,be%20more%20efficient%20and%20productive). For example, with an admin action extension, a merchant might click “More actions” on an order and launch the app’s modal to perform a task (like generating a shipping label)[\[76\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=Anchor%20to%20Admin%20actionsAdmin%20actions). With an admin block, a merchant could see a persistent card on a product page showing data from the app (and potentially interact with it)[\[77\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=Anchor%20to%20Admin%20blocksAdmin%20blocks). Admin UI extensions use the standard Shopify UI Extensions framework – you build them using React or vanilla JS and target specific admin pages. The guide describes each type: **Admin actions** are transactional modals accessible via actions menus (e.g., on Products, Orders pages)[\[76\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=Anchor%20to%20Admin%20actionsAdmin%20actions), **Admin print actions** are similar but specifically appear under a “Print” menu and have APIs to preview/print documents (like printing an invoice from an order)[\[78\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=Anchor%20to%20Admin%20print%20actionsAdmin,print%20actions), and **Admin blocks** are card-style UI elements embedded directly on pages (e.g., a block on a product details page that shows info and allows input)[\[77\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=Anchor%20to%20Admin%20blocksAdmin%20blocks). Blocks can even launch actions – for instance, a block might include an “Edit” button that opens an admin action modal for editing data[\[79\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=With%20admin%20blocks%2C%20merchants%20can,actions%20directly%20from%20admin%20blocks). The doc highlights that UI extensions help merchants be more efficient by keeping relevant app functionality in context, on Shopify’s pages[\[80\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=to%20embed%20workflows%20and%20UX,be%20more%20efficient%20and%20productive)[\[81\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=Admin%20blocks%20are%20built%20with,before%20they%20can%20use%20it). It also notes that to create these extensions you’ll use Shopify’s UI Extensions APIs and define extension targets corresponding to admin locations[\[82\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=You%20can%20create%20UI%20extensions,to%20the%20extension%20target%20reference). In summary, _About admin UI extensions_ frames them as the modern way to integrate app UIs into the admin: **actions for workflows in modals, blocks for persistent info/UI on pages**, all built to look native to Shopify’s design[\[75\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=UI%20extensions%20enable%20you%20to,be%20more%20efficient%20and%20productive)[\[83\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=Admin%20print%20actions%20are%20a,a%20document%20and%20print%20it).

### Build an Admin Action UI Extension (Tutorial)

This is a step-by-step tutorial (part 1 of a series) that teaches you how to create an **admin action extension** for the Shopify admin. In the provided example, the tutorial builds an action that allows merchants to log “issues” on a product (imagine a simple issue tracker for products)[\[84\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-action?extension=react#:~:text=This%20guide%20is%20the%20first,trackable%2C%20resolvable%20issues%20on%20products)[\[85\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-action?extension=react#:~:text=In%20this%20tutorial%2C%20you%27ll%20learn,to%20do%20the%20following%20tasks). The guide covers generating the extension using Shopify CLI, which produces a new extension in your app’s extensions/ folder (with a template for an admin action UI)[\[86\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-action?extension=react#:~:text=shopify%20app%20generate%20extension%20,flavor%20react)[\[87\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-action?extension=react#:~:text=extensions%2Fissue). Then it walks through coding the extension: setting the extension’s target to the product details page, fetching product data or initial state for the modal, creating the modal’s UI (fields for issue title/description), and writing the logic to save the issue via GraphQL (perhaps tagging the product or storing data in the app)[\[85\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-action?extension=react#:~:text=In%20this%20tutorial%2C%20you%27ll%20learn,to%20do%20the%20following%20tasks)[\[88\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-action?extension=react#:~:text=,it%20on%20a%20development%20store). You learn how to use Polaris components inside the extension’s React code and how to test the extension by running shopify app dev and previewing it on a dev store. By the end, the merchant can go to a product in admin, click an action (e.g., “Log issue” under More actions), and see a modal from the app to submit an issue[\[84\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-action?extension=react#:~:text=This%20guide%20is%20the%20first,trackable%2C%20resolvable%20issues%20on%20products)[\[88\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-action?extension=react#:~:text=,it%20on%20a%20development%20store). This tutorial illustrates how admin actions **extend existing admin workflows**: they appear contextually and complete a task without navigating away. It’s also the foundation for subsequent parts where that data (the logged issues) will be displayed via an admin block. Overall, _Build an admin action UI extension_ shows the full process from generating extension code to implementing UI and GraphQL operations, enabling an app developer to add a custom **modal action** into Shopify’s UI[\[85\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-action?extension=react#:~:text=In%20this%20tutorial%2C%20you%27ll%20learn,to%20do%20the%20following%20tasks)[\[86\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-action?extension=react#:~:text=shopify%20app%20generate%20extension%20,flavor%20react).

### Build an Admin Block UI Extension (Tutorial)

In part 2 of the series, **“Build an admin block UI extension”**, you create an **admin block** that surfaces information (the issues logged) on the product page itself[\[89\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-block?extension=react#:~:text=So%20far%2C%20you%27ve%20created%20a,created%20issues%20for%20a%20product). This tutorial assumes you completed the admin action from part 1, which created “issues”. Now you build a block to list those issues at the bottom of the product page, so the merchant can see all issues for a product at a glance[\[89\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-block?extension=react#:~:text=So%20far%2C%20you%27ve%20created%20a,created%20issues%20for%20a%20product)[\[90\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-block?extension=react#:~:text=In%20this%20tutorial%2C%20you%27ll%20learn,to%20do%20the%20following%20tasks). Steps include generating an admin block extension (shopify app generate extension --template admin_block), which creates the scaffold and config for a block[\[91\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-block?extension=react#:~:text=2,new%20admin%20block%20UI%20extension)[\[92\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-block?extension=react#:~:text=shopify%20app%20generate%20extension%20,flavor%20react). Then, implementing the block’s React code to fetch issues (likely via GraphQL or App Bridge queries to your app’s backend) and display them in a card UI on the product page. The tutorial also demonstrates how to use Shopify’s **contextual save bar** for blocks if the block has editable fields (in this case, possibly allowing inline edits of the issues)[\[93\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-block?extension=react#:~:text=,the%20UI%20extension%27s%20initial%20state). After coding, you run the app and preview the block in the checkout editor or admin to ensure it renders the issue list correctly. The result is an admin block that complements the earlier action: the action adds data (issues), and the block persistently shows that data on the product page[\[89\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-block?extension=react#:~:text=So%20far%2C%20you%27ve%20created%20a,created%20issues%20for%20a%20product)[\[94\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-block?extension=react#:~:text=,on%20the%20product%20details%20page). This reflects a common pattern – **admin blocks and actions working together** for a feature set. Through this tutorial, a developer learns how to position an app’s block on a specific admin page, how to structure its configuration (targets in the TOML, etc.), and how to safely retrieve and render app data in the admin context. (In the series, subsequent guides will connect the action and block so you can create/edit issues from the block itself.) In sum, _Build an admin block UI extension_ teaches embedding a custom **info panel (block)** in Shopify admin, providing merchants with at-a-glance data from the app[\[90\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-block?extension=react#:~:text=In%20this%20tutorial%2C%20you%27ll%20learn,to%20do%20the%20following%20tasks)[\[92\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-block?extension=react#:~:text=shopify%20app%20generate%20extension%20,flavor%20react).

### Connect Admin UI Extensions (Linking Actions & Blocks)

Part 3 of the series, **“Connect admin UI extensions”**, focuses on making the previously built admin action and block work in unison. The scenario is that merchants would like to not only see issues in the block but also **create or edit issues directly from that block**, instead of having to use the separate “More actions” menu[\[95\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-admin-extensions?extension=react#:~:text=At%20this%20point%20in%20the,used%20in%20the%20same%20location)[\[96\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-admin-extensions?extension=react#:~:text=Now%2C%20you%27ll%20modify%20the%20block,issues%20directly%20from%20the%20block). To achieve this, the guide modifies the admin block to include, say, an “Add issue” button (or edit buttons next to each issue) that programmatically triggers the admin action extension modal[\[97\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-admin-extensions?extension=react#:~:text=,edit%20or%20create%20a%20resource)[\[98\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-admin-extensions?extension=react#:~:text=action%20form). It introduces the concept of launching an admin action from another extension by using an **“intent”** parameter – essentially, passing context to the action about what it should do (e.g., open in “edit” mode for a specific issue vs. “create” mode)[\[99\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-admin-extensions?extension=react#:~:text=Anchor%20to%20What%20you%27ll%20learnWhat,you%27ll%20learn)[\[97\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-admin-extensions?extension=react#:~:text=,edit%20or%20create%20a%20resource). The steps involve updating the block’s code to call the navigation.navigate API or a similar method to open the action modal with a specific intent, and updating the action extension to listen for that intent (perhaps via props or by reading extension local storage) and adjust its behavior accordingly[\[97\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-admin-extensions?extension=react#:~:text=,edit%20or%20create%20a%20resource)[\[98\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-admin-extensions?extension=react#:~:text=action%20form). After these changes, the merchant experience improves: they can click an “Add issue” inside the block on the product page, the action modal opens (now aware it’s creating a new issue from that context), and once saved, the block updates to show the new issue – all in one place[\[95\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-admin-extensions?extension=react#:~:text=At%20this%20point%20in%20the,used%20in%20the%20same%20location)[\[96\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-admin-extensions?extension=react#:~:text=Now%2C%20you%27ll%20modify%20the%20block,issues%20directly%20from%20the%20block). This tutorial highlights how multiple UI extensions from the same app can **inter-communicate and provide a unified experience**. Developers learn to use extension API features like ExtensionPoint communication or deep linking between extensions. The end result is a smoother workflow for the merchant and an example of combining extensions (block + action) to build richer app functionality in admin[\[95\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-admin-extensions?extension=react#:~:text=At%20this%20point%20in%20the,used%20in%20the%20same%20location)[\[97\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-admin-extensions?extension=react#:~:text=,edit%20or%20create%20a%20resource).

### Connect UI Extensions to Your App’s Backend (Checkout/Server Integration)

_(Note: The link title suggests connecting UI extensions to the app backend – in the context of the series, this is likely part 4 about pulling in outside data. However, the content we opened was for hiding extensions. We will interpret it generally.)_

Often, an admin UI extension might need data from the app’s backend (for example, to fetch suggestions or enforce rules stored on the server). The **“Connect UI extensions to your app's backend”** tutorial shows how to have an admin extension make authenticated calls to the app’s server-side. In a Shopify app, you can create custom endpoints (e.g., in your Node/Remix/Rails app) and use the session token to authorize requests from the extension. This guide’s example adds a “Generate issue” button that, when clicked, requests the app backend to supply a suggested title/description for a new issue[\[100\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=So%20far%20you%27ve%20used%20direct,in%20an%20admin%20UI%20extension)[\[101\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=To%20demonstrate%20this%2C%20we%27ll%20build,values%20from%20the%20app%27s%20backend). To do so, the tutorial has you create a new **resource route** in your app (for Remix, this might be an API route that returns JSON). It emphasizes wrapping responses with the cors() helper from authenticate.admin() to ensure the extension (running on a different origin) can fetch it[\[102\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=Create%20a%20resource%20route%20in,suggested%20issue%20titles%20and%20descriptions). Then, in the admin action extension code, you use a standard fetch() call to hit that endpoint – the extension environment automatically adds the required auth headers (the session token) and uses the app’s base URL, so the call is authenticated to your app[\[103\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=Now%20that%20your%20app%20has,extension%27s%20title%20and%20description%20fields). The data returned (e.g., a suggested issue title) is then used to pre-fill the form fields in the action extension. This pattern shows developers how to **extend their extension’s capabilities beyond the browser**, enabling complex logic or data that lives on the server to be brought into the admin UI extension[\[104\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=In%20this%20tutorial%2C%20you%27ll%20learn,to%20do%20the%20following%20tasks)[\[103\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=Now%20that%20your%20app%20has,extension%27s%20title%20and%20description%20fields). After implementing this, when a merchant clicks “Generate suggestion”, the extension fetches from the app’s backend (maybe running an AI or database lookup) and then populates the issue form automatically[\[101\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=To%20demonstrate%20this%2C%20we%27ll%20build,values%20from%20the%20app%27s%20backend)[\[103\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=Now%20that%20your%20app%20has,extension%27s%20title%20and%20description%20fields). This greatly enriches what extensions can do. In summary, _Connect UI extensions to your app’s backend_ teaches how to build a secure bridge between the **admin extension (frontend)** and the **app backend**, using session tokens and CORS to safely fetch data so that extensions can have dynamic, server-driven content[\[105\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=,can%20use%20to%20fetch%20data)[\[103\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=Now%20that%20your%20app%20has,extension%27s%20title%20and%20description%20fields).

### Hide Admin UI Extensions (Conditional Rendering)

The final part (part 5) of the series, **“Hide admin UI extensions”**, demonstrates implementing conditional logic so that your admin extensions only appear when relevant. In the example, the app’s issue tracker extensions might not always apply – say the app should only be used on products with more than one variant (multi-variant products). This tutorial shows how to **collapse or hide an admin block** when conditions aren’t met, and similarly remove the admin action from the “More actions” menu if not needed[\[106\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/hide-extensions?extension=react#:~:text=So%20far%20you%27ve%20created%20UI,not%20relevant%20to%20the%20target)[\[107\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/hide-extensions?extension=react#:~:text=,not%20relevant%20to%20the%20target). The solution was to check the product’s variant count: if it’s 1, then the block should not render and the action menu item should be suppressed[\[108\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/hide-extensions?extension=react#:~:text=To%20demonstrate%20conditional%20logic%2C%20we%27ll,UI%20extension%20will%20be%20hidden). Technically, you update the block’s code to return null (no UI) when shouldRender is false, effectively collapsing the block section[\[109\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/hide-extensions?extension=react#:~:text=If%20an%20admin%20block%20isn%27t,component%20of%20your%20UI%20extension). And you update the extension’s configuration or registration for the action to include a condition (possibly using the extension’s capability to hide via contextual conditions or by programmatically not registering if not applicable). The result is that for single-variant products, the UI extension is hidden, keeping the admin interface clean[\[110\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/hide-extensions?extension=react#:~:text=Anchor%20to%20Collapse%20an%20admin,blockCollapse%20an%20admin%20block)[\[109\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/hide-extensions?extension=react#:~:text=If%20an%20admin%20block%20isn%27t,component%20of%20your%20UI%20extension). This guide teaches developers to consider **contextual relevance** – an app should not clutter the UI when its feature doesn’t apply. It also shows how to fetch necessary data (like variant count via GraphQL or metafields) within the extension and use it to decide whether to render content[\[111\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/hide-extensions?extension=react#:~:text=should%20be%20visible,admin%20block%20should%20be%20visible). Additionally, it illustrates hiding an action menu item by configuration (so merchants don’t see a disabled or pointless action)[\[107\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/hide-extensions?extension=react#:~:text=,not%20relevant%20to%20the%20target). In summary, _Hide admin UI extensions_ covers best practices for **conditional UI** in admin: only showing blocks and actions when the merchant will find them useful, thereby improving UX and avoiding confusion[\[108\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/hide-extensions?extension=react#:~:text=To%20demonstrate%20conditional%20logic%2C%20we%27ll,UI%20extension%20will%20be%20hidden)[\[112\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/hide-extensions?extension=react#:~:text=,not%20relevant%20to%20the%20target).

### Admin Link Extensions (Legacy Navigation Links)

**Admin link extensions** create simple linked shortcuts in the Shopify admin that send merchants to a page in your app (usually opening the app in the admin). Historically, there were “admin links” (for single resources) and “bulk action links” (for selections) configured via the Partners Dashboard, but now these have been unified into admin link extensions managed by CLI[\[113\]](https://shopify.dev/docs/apps/build/admin/admin-links#:~:text=Anchor%20to%20Migrating%20from%20admin,links%20and%20bulk%20action%20links). The _About admin link extensions_ guide explains that these are typically used to direct merchants from a Shopify admin page (like an order or product page) to a related page in the app for more complex workflows[\[114\]](https://shopify.dev/docs/apps/build/admin/admin-links#:~:text=Admin%20link%20extensions%20let%20you,an%20automation%20for%20any%20order). For example, Shopify’s own Flow app adds an admin link on orders that says “Run automation” – clicking it jumps the merchant into the Flow app’s order automation screen[\[114\]](https://shopify.dev/docs/apps/build/admin/admin-links#:~:text=Admin%20link%20extensions%20let%20you,an%20automation%20for%20any%20order)[\[115\]](https://shopify.dev/docs/apps/build/admin/admin-links#:~:text=to%20related%2C%20complex%20workflows%20in,an%20automation%20for%20any%20order). Admin links automatically include URL parameters indicating the context (store and resource IDs), so the app knows which resource the merchant came from[\[116\]](https://shopify.dev/docs/apps/build/admin/admin-links#:~:text=Admin%20link%20extensions%20dynamically%20append,relevant%20experiences%20in%20your%20app). The docs _caution_ that often an admin action UI extension is preferable to a link, as it keeps the merchant in context with a modal rather than a full page load[\[117\]](https://shopify.dev/docs/apps/build/admin/admin-links#:~:text=Note). However, links are still useful for deeply complex flows that can’t fit in a modal. The _Create admin link extensions_ tutorial shows generating a link extension via CLI and editing its shopify.extension.toml – you specify the **target** (e.g., admin.product.details.more_actions or similar) and the URL path in your app that the link should open[\[118\]](https://shopify.dev/docs/apps/build/admin/admin-links/create-admin-links#:~:text=%24)[\[119\]](https://shopify.dev/docs/apps/build/admin/admin-links/create-admin-links#:~:text=). You can also localize the link’s label (the extension supports multiple languages)[\[120\]](https://shopify.dev/docs/apps/build/admin/admin-links/create-admin-links#:~:text=,that%20have%20your%20app%20installed)[\[121\]](https://shopify.dev/docs/apps/build/admin/admin-links/create-admin-links#:~:text=target%20%3D%20). After deploying, merchants will see a new menu item or link on the chosen admin page that opens the app. The _Migrate to admin link extensions_ guide covers importing any old Partner Dashboard links using shopify app import-extensions – CLI will create extension files for them so you can manage them as code[\[122\]](https://shopify.dev/docs/apps/build/admin/admin-links/migrate-admin-links#:~:text=Anchor%20to%20Step%201%3A%20Import,1%3A%20Import%20existing%20admin%20links)[\[123\]](https://shopify.dev/docs/apps/build/admin/admin-links/migrate-admin-links#:~:text=shopify%20app%20import). Then you deploy a new app version, which removes the dashboard-managed links in favor of your code-managed ones[\[124\]](https://shopify.dev/docs/apps/build/admin/admin-links/migrate-admin-links#:~:text=Anchor%20to%20Step%202%3A%20Deploy,2%3A%20Deploy%20your%20link%20extensions)[\[125\]](https://shopify.dev/docs/apps/build/admin/admin-links/migrate-admin-links#:~:text=%24). In summary, **admin link extensions** are simple but useful navigational hooks: they don’t embed UI directly but funnel merchants from Shopify admin to the app. They are now managed via CLI (with benefits like version control and localization), and if you have existing links from older setups, Shopify provides a migration path[\[113\]](https://shopify.dev/docs/apps/build/admin/admin-links#:~:text=Anchor%20to%20Migrating%20from%20admin,links%20and%20bulk%20action%20links)[\[123\]](https://shopify.dev/docs/apps/build/admin/admin-links/migrate-admin-links#:~:text=shopify%20app%20import).

## Apps in Checkout (Customization of the Checkout Process)

### Apps in Checkout (Overview & Extension Options)

Shopify Checkout is the standardized flow customers go through to enter their info and complete orders. **Apps in checkout** allow merchants to **customize and extend the checkout experience** by using various extension points and Functions[\[126\]](https://shopify.dev/docs/apps/build/checkout#:~:text=After%20a%20customer%20adds%20products,information%20before%20placing%20the%20order). After a customer adds products to cart and moves to checkout, usually they see Shopify’s default steps (contact, shipping, payment). With checkout extensions, apps can introduce new UI or logic – for example, offering a free gift based on cart contents, validating certain inputs before allowing payment, or integrating a loyalty program step[\[127\]](https://shopify.dev/docs/apps/build/checkout#:~:text=To%20extend%20checkout%2C%20apps%20can,the%20contents%20of%20their%20cart)[\[128\]](https://shopify.dev/docs/apps/build/checkout#:~:text=,Payments%20extensions). Merchants manage checkout extensions via the **Checkout Editor** in the admin, where they can drag-and-drop extension blocks into their checkout layout[\[129\]](https://shopify.dev/docs/apps/build/checkout#:~:text=the%20contents%20of%20their%20cart). Shopify currently supports a few technologies for checkout customization: **Checkout UI Extensions** (UI components rendered in checkout), **Shopify Functions** (backend customizations like discount or shipping logic), **Web Pixel extensions** (analytics scripts for checkout events), and **Payments customizations** (custom payment gateways)[\[130\]](https://shopify.dev/docs/apps/build/checkout#:~:text=There%20are%20various%20types%20of,can%20use%20to%20customize%20checkout). All these options are designed to be **upgrade-safe and easily installed** by merchants (for instance, a checkout UI extension won’t break when Shopify updates checkout, unlike old script hacks)[\[131\]](https://shopify.dev/docs/apps/build/checkout#:~:text=). The _Apps in checkout_ overview emphasizes that any checkout changes must adhere to Shopify’s stringent **design and performance guidelines**[\[132\]](https://shopify.dev/docs/apps/build/checkout#:~:text=For%20a%20detailed%20breakdown%20of,options%20for%20customizing%20Shopify%20checkout) – checkout is a critical flow, so extensions face rules (like not collecting prohibited data and maintaining speed). In essence, _Apps in checkout_ sets the stage: it’s possible to augment checkout via approved extension points, and developers should choose the right approach (UI, Function, etc.) depending on whether they need to add interface elements, enforce business logic, track events, or process payments[\[130\]](https://shopify.dev/docs/apps/build/checkout#:~:text=There%20are%20various%20types%20of,can%20use%20to%20customize%20checkout)[\[133\]](https://shopify.dev/docs/apps/build/checkout#:~:text=or%20features%20such%20as%20One,checkout).

### Technologies for Customizing Shopify Checkout

Shopify provides a detailed breakdown of **checkout customization technologies** and when to use each[\[134\]](https://shopify.dev/docs/apps/build/checkout#:~:text=,Payments%20extensions). This includes:

- **Checkout UI Extensions** – for inserting or altering UI in the checkout front-end. These are used to add content or inputs (e.g., an upsell offer, custom form field, banner message) in specific checkout locations. UI extensions run in the browser and can respond to customer interactions immediately[\[135\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=You%20can%20build%20functionality%20in,to%20provide%20the%20following%20experiences)[\[136\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=You%20can%20use%20a%20checkout,side%20validation%20at%20checkout).
- **Shopify Functions** (for Checkout) – for custom backend logic executed during checkout processing. Examples are discount functions (providing custom discount types), delivery option or shipping rate functions (modifying shipping methods), and checkout validation functions (blocking checkout based on custom criteria)[\[137\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=Anchor%20to%20Server)[\[138\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=By%20validating%20cart%20and%20checkout,them%20from%20proceeding%20through%20checkout). Functions are fast, server-side, and ensure rules are enforced even if front-end scripts are bypassed[\[139\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=A%20benefit%20of%20client,efficient%20and%20streamlined%20user%20experience)[\[140\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=You%20can%20use%20Shopify%20Functions,side).
- **Payment Gateway Extensions** – for integrating new payment methods or custom payment behavior in checkout. (This is a specialized area requiring Shopify approval – e.g., adding a new credit card gateway or buy-now-pay-later option via the Payments Platform)[\[141\]](https://shopify.dev/docs/apps/build/payments#:~:text=Payments%20extensions%20integrate%20with%20the,extensions%20on%20Shopify%27s%20Payments%20Platform)[\[142\]](https://shopify.dev/docs/apps/build/payments#:~:text=There%20are%20five%20types%20of,payments%20extensions).
- **Web Pixel Extensions** – for injecting tracking pixels or scripts into checkout to gather analytics (e.g., Google Analytics, Facebook Pixel) in a safe, approved way. These run at checkout events and send data to external endpoints, without interfering with checkout itself.

The _Technologies for customizing checkout_ guide likely explains **which extension points exist for UI** (like extension targets: post-purchase page, checkout order summary, shipping address form, etc.) and how they relate to corresponding Function hooks. It references a separate page listing all the extension targets and possibilities[\[143\]](https://shopify.dev/docs/apps/build/checkout#:~:text=For%20a%20detailed%20breakdown%20of,options%20for%20customizing%20Shopify%20checkout). In summary, this guide helps developers decide how to implement a desired customization: If it’s about UI or capturing input – use a Checkout UI Extension; if it’s about pricing or validation – use a Function; if it’s a payment method – build a Payments extension; if it’s analytics – use a Web Pixel. Importantly, these methods are **composable** – e.g., an app might combine a UI extension (to get user input) with a Function (to apply a discount) to achieve a cohesive feature. All approaches are **merchant-installable** and don’t require editing theme code, preserving upgradability of checkout[\[131\]](https://shopify.dev/docs/apps/build/checkout#:~:text=).

### Start Building for Checkout (Quick Start)

**“Start building for checkout”** is a quick-start tutorial to begin developing checkout customizations. It walks through initial setup: ensuring you have a development store with **Checkout UI Extensions enabled** (this requires enabling the Checkout Extensibility developer preview for non-Plus stores)[\[144\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=Anchor%20to%20RequirementsRequirements), and using Shopify CLI to scaffold your first extension. The guide suggests using shopify app init to create an app and then shopify app generate extension to create an extension of a chosen type (you can select “Checkout UI” or “Post-purchase UI” or a Function, etc.)[\[145\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=Terminal)[\[146\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=4,the%20following%20extension%20types). It then covers running shopify app dev to preview the extension on a dev store checkout – often by pressing p to open the dev console and then clicking a preview link for the extension[\[147\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=6,following%20steps)[\[148\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=%24). This quick-start emphasizes that **Shopify CLI scaffolds boilerplate** for you and automates serving the extension in a checkout session for testing[\[149\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=To%20get%20started%20with%20checkout,and%20automates%20common%20development%20tasks)[\[150\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=Copy). It also mentions you might need to use the --checkout-cart-url flag to direct the CLI to a specific cart URL if the preview doesn’t launch automatically (for instance, to avoid the “property token” error)[\[151\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=If%20you%20receive%20the%20error,a%20checkout%20session%20for%20you)[\[152\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=%24). The guide’s mention of GraphQL Admin API usage for styling checkout indicates it also points out alternative approaches (like using Admin API to set branding colors/fonts on checkout) for merchants on Plus who can style checkout[\[153\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=The%20following%20is%20a%20lightweight,settings%20on%20checkout%20form%20fields). In short, _Start building for checkout_ is a concise guide to get a developer from zero to seeing “Hello World” in checkout, by generating an extension and loading it on a dev store. After this, a developer can follow more specific tutorials to implement particular features. It ensures the basic **prerequisites** are covered (Partner account, dev store, CLI updated, and Rust toolchain if building Functions in Rust)[\[144\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=Anchor%20to%20RequirementsRequirements)[\[154\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=Anchor%20to%20Language,writing%20Shopify%20Functions%20in%20Rust) and that the developer knows how to **serve and preview** their extension during development[\[147\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=6,following%20steps)[\[148\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=%24).

### Cart and Checkout Validation (Enforcing Requirements)

**Cart and checkout validation** refers to enforcing custom business rules during the checkout process. The _About cart and checkout validation_ guide introduces two complementary approaches: **client-side validation** using a Checkout UI Extension and **server-side validation** using a Shopify Function[\[135\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=You%20can%20build%20functionality%20in,to%20provide%20the%20following%20experiences). Validation might be used to ensure an order meets certain criteria before the customer can complete it – for example, requiring a minimum age, disallowing shipping to certain locations, or limiting quantities.

– _Client-side validation:_ This uses a checkout UI extension that runs in the browser during checkout. It can check the customer’s input or cart contents in real time and prevent progression if criteria aren’t met[\[136\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=You%20can%20use%20a%20checkout,side%20validation%20at%20checkout)[\[155\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=By%20validating%20checkout%20information%20in,18%20from%20making%20a%20purchase). For instance, a UI extension could be placed on the shipping address step to detect if the address is a PO Box and immediately show an error, blocking the “Continue” button. Client-side validation provides **immediate feedback** to customers (a better UX)[\[156\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=block%20customers%20under%20the%20age,18%20from%20making%20a%20purchase). However, it’s not foolproof because a tech-savvy user could bypass client checks – thus it’s recommended to pair with server-side validation for critical rules[\[157\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=issues%20sooner%2C%20leading%20to%20a,efficient%20and%20streamlined%20user%20experience).

– _Server-side validation:_ This is implemented as a Shopify Function (specifically a Cart/Checkout Validation Function) that runs on Shopify’s servers when the customer attempts to checkout[\[137\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=Anchor%20to%20Server). The function can inspect the cart/order and **block the checkout submission** with an error message if the rule is violated[\[138\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=By%20validating%20cart%20and%20checkout,them%20from%20proceeding%20through%20checkout). For example, the function could enforce “no more than 5 of product X per order” regardless of any client-side checks. Server-side validation is **secure and authoritative** – it cannot be bypassed, ensuring business logic is upheld[\[157\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=issues%20sooner%2C%20leading%20to%20a,efficient%20and%20streamlined%20user%20experience)[\[158\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=Using%20Shopify%20Functions%20for%20server,carts%20built%20for%20custom%20storefronts). It works for both online store carts (Ajax or Online Store 2.0 cart page) and the actual checkout. The guide notes that this is the recommended approach for serious validations, with client-side as a user-friendly enhancement[\[159\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=However%2C%20it%27s%20important%20to%20note,program%20points%20are%20properly%20redeemed)[\[158\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=Using%20Shopify%20Functions%20for%20server,carts%20built%20for%20custom%20storefronts).

This section also references that **Flow** (Shopify’s automation app) or other tools could be used for some validations, but for immediate checkout blocks, Functions are the way. It then points to tutorials: one for building client-side validation extension, one for building a server-side function, and one for creating an admin UI (Function setting) to allow merchant configuration of the validation criteria[\[160\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=Follow%20these%20tutorials%20to%20get,with%20building%20validations%20in%20checkout). For example, a tutorial might show how to build a validation function that blocks checkout if cart total exceeds a certain amount, plus an admin UI extension that lets the merchant set that maximum value[\[161\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=Create%20client,according%20to%20the%20merchant%27s%20preferences). In summary, _Cart and checkout validation_ is about **ensuring order requirements**: use **UI extensions** for instant feedback in checkout (good UX)[\[155\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=By%20validating%20checkout%20information%20in,18%20from%20making%20a%20purchase), but rely on **Functions** for guaranteed enforcement on the backend (correctness and security)[\[162\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=You%20can%20use%20Shopify%20Functions,side).

### Display Custom Data at Checkout (UI Extension Example)

This tutorial describes adding a Checkout UI Extension that displays extra information to the customer during checkout – for instance, showing a custom message or metafield data beneath each cart item. The _Display custom data at checkout_ guide has you create a new checkout UI extension and target a specific extension point, in this case purchase.checkout.cart-line-item.render-after (which renders content after each line item on the order summary)[\[163\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=This%20extension%20uses%20the%20%60purchase.checkout.cart,custom%20data%20after%20the%20product). The tutorial walks through configuring the extension target in code and in the shopify.extension.toml (defining the target location and which file to load)[\[164\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=Anchor%20to%20Set%20up%20an,targetSet%20up%20an%20extension%20target)[\[165\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=In%20your%20checkout%20UI%20extension%27s,section%20with%20the%20following%20information). It then shows how to retrieve the data you want to display – for example, using useAppMetafields to fetch a product metafield for each cart line, and useCartLines to iterate over the items[\[166\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=Anchor%20to%20Import%20the%20following,resources%20to%20render%20the%20extension). In this scenario, perhaps each product has a metafield (like a custom warranty or ingredient info) that the app wants to show the customer before purchase. The extension’s React code imports Shopify Checkout UI components like Text for displaying text and uses the values from useAppMetafields (which would contain the metafield data if the app properly registered the metafield namespace/key in the extension config)[\[166\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=Anchor%20to%20Import%20the%20following,resources%20to%20render%20the%20extension). The guide reminds you to declare what metafields your extension needs in the config file so Shopify provides that data to the extension[\[167\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=Anchor%20to%20Reference%20the%20metafield,metafield%20in%20the%20configuration%20file)[\[168\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=Create%20an%20%60,created%20in%20the%20Shopify%20admin). After implementation, you start the dev server and preview the checkout – now, under each product, your custom data appears. This kind of extension is useful for showing things like _“This item is on backorder”_ or _“Ships cold, handle with care”_ messages, or additional charges or info per item. The tutorial also covers troubleshooting common issues, such as ensuring you append ?dev= query param if shopify app dev doesn’t auto-open the checkout preview, and how to manually test by adding items and then reloading checkout with the dev URL[\[151\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=If%20you%20receive%20the%20error,a%20checkout%20session%20for%20you)[\[169\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=4,using%20a%20unique%20HTTPS%20URL). Overall, _Display custom data at checkout_ teaches how to use a **Checkout UI Extension target and APIs to inject dynamic, app-sourced content into checkout’s UI**, which improves the richness of information customers see before placing orders[\[163\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=This%20extension%20uses%20the%20%60purchase.checkout.cart,custom%20data%20after%20the%20product)[\[166\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=Anchor%20to%20Import%20the%20following,resources%20to%20render%20the%20extension).

### Cart Permalinks (Shareable Cart Links)

**Cart permalinks** allow creating a URL that leads directly to a pre-filled cart or checkout. The _Create cart permalinks_ guide covers how an app can generate a link (e.g., for an email or social media) that when clicked, adds specific products (and quantities) to the customer’s cart and takes them to the checkout or cart page. This is often used for “Build a cart” or “Buy Now” buttons outside the store. The guide likely shows using the Admin API or a Storefront API mutation to create a Cart Permalink or using a predetermined URL format (Shopify supports a URL pattern like /cart/{variant_id}:{qty},{variant_id2}:{qty2}...). For instance, the app might compute a URL like <https://storename.myshopify.com/cart/12345:2,67890:1?channel=>... that includes the specified items. The documentation would highlight including any necessary query params (like checkout\[discount\]=CODE for discount, or channel for sales channel attribution). By following this guide, developers can programmatically **create one-click cart links** for use in marketing campaigns or integrations. (This guide doesn’t have a snippet to cite directly, as it was not fully opened, but conceptually it’s about constructing and using the cart permalink format.)

The key point: _Create cart permalinks_ shows how apps can offer merchants or customers a convenient way to share a cart – improving conversion by pre-loading items. It ensures developers know the correct URL structure or API to generate these links and how to handle edge cases (like items out of stock or variants that require selling plans, etc.).

### Checkout Styling (Branding Customizations)

Shopify allows certain styling customizations on checkout for Plus merchants (and via developer preview for others) – for example, changing typography, colors, or adding a logo/favicon. The _About checkout styling_ section introduces how developers or merchants can alter the visual style of checkout pages to match branding. It references that this can be done via the GraphQL Admin API’s **CheckoutBranding** settings or through the **Checkout UI Extensions** if needed[\[153\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=The%20following%20is%20a%20lightweight,settings%20on%20checkout%20form%20fields). Specific guides under styling include: **Customize typography** (choosing fonts and font sizes), **Add the favicon** (uploading a custom favicon for the checkout pages), **Customize form controls** (corner radius, field style), **Update color settings** (primary button color, accent color, etc.), and **Customize sections** (possibly toggling sections like a banner or message at top).

Each of these is likely a short guide on using the Admin API to set branding attributes. For example, _Customize typography_ might instruct setting checkoutBranding.font_body and related fields via GraphQL, or using the merchant admin to select from allowed fonts. _Add the favicon_ could show how to upload an image and set the checkoutBranding.favicon_image URL. _Customize form controls_ probably covers customizing the shape/outline of input fields by setting checkoutBranding.input_style properties. _Update color settings_ instructs on setting checkoutBranding.accent and others to hex values. _Customize sections_ might allow showing/hiding certain default sections or adding a custom message using a UI extension.

Because checkout styling is mostly separate from extensions (it’s more about Shopify Plus branding settings), the key takeaway is: **Developers can programmatically set checkout branding** to ensure the checkout’s look (colors, fonts, logos) aligns with the merchant’s brand. This can be part of an app’s onboarding (for example, an app could apply a theme’s color scheme to checkout automatically via API).

The documentation likely provides examples or API mutation payloads for these changes, ensuring developers know how to safely apply style changes (and revert if needed). It warns to only use allowed modifications – Shopify still maintains overall layout and can reject overly invasive changes. (We cite the quick reference that a guide exists to “style checkout for a brand” which implies these customizations[\[153\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=The%20following%20is%20a%20lightweight,settings%20on%20checkout%20form%20fields).)

### Customize the Header & Footer in Checkout

These two guides (header and footer) demonstrate using **Checkout UI Extensions** to add custom content to the very top or bottom of the checkout page. For instance, _Customize the header_ might show placing a banner at the checkout’s header – such as an image or a message (e.g., store logo, or a countdown timer for a sale)[\[170\]](https://shopify.dev/docs/apps/build/checkout#:~:text=instructions%20to%20their%20order.%20Client,extension%20to%20customize%20the%20address). It references using the GraphQL Admin API’s branding fields or a UI extension combined with branding: one approach is adding images via the branding API, another is injecting content via an extension point specifically for the header (Shopify provides an extension target for checkout header). The tutorial likely chooses to demonstrate an extension that includes an image (maybe a trust badge or custom logo beyond the default) and a “Back to cart” link as a custom element, as hinted[\[171\]](https://shopify.dev/docs/apps/build/checkout#:~:text=instructions%20to%20their%20order.%20Client,and%20the%20GraphQL%20Admin%20API%27s).

Similarly, _Customize the footer_ shows adding elements at the bottom of checkout – for example, custom text like store policies or help links that aren’t part of the standard policy links, or reordering those links[\[172\]](https://shopify.dev/docs/apps/build/checkout#:~:text=extension%20to%20validate%20fields%20at,the%20checkout%20footer%20with%20store). The guide probably has you create a checkout UI extension targeting Checkout::Dynamic::RenderFooter (or similar target) and then use Polaris or plain HTML to add the content.

These tutorials reinforce how to use **pre-defined extension targets** to inject content in otherwise non-editable areas of checkout. They also likely incorporate the **Checkout Branding API** where relevant (for example, instructing that if you want to change the “Back to cart” link text or URL, that might be part of branding or an extension configuration).

By following these, developers can give merchants more flexibility with checkout appearance – e.g., displaying a support phone number at checkout header, or a thank-you note in the footer. It all ties into making checkout more on-brand and informative without altering core functionality.

### Custom Banners and Fields in Checkout

Shopify now supports adding **custom banners** (informational messages) and **custom fields** (extra input fields) to checkout via UI extensions. The _About custom banners and fields_ guide introduces how these can be used: for example, a merchant might add a banner to show a shipping delay notice, or a custom field to ask for “delivery instructions” or “gift message” from the customer[\[173\]](https://shopify.dev/docs/apps/build/checkout#:~:text=extension,and%20the%20GraphQL%20Admin%20API%27s)[\[174\]](https://shopify.dev/docs/apps/build/checkout#:~:text=instructions%20to%20their%20order.%20Client,45).

The _Add a field to checkout_ tutorial likely leads you through creating a checkout UI extension that defines a new input field at a certain step of checkout (shipping or payment step). It would cover capturing the field’s value and attaching it to the order (commonly via order metafields or notes). It may involve marking the field as required or not, and ensuring the data flows to the admin (the app might listen to a webhook or use an order meta to save it). For instance, adding a “Order delivery date” picker or “Agree to terms” checkbox. The extension uses components like TextField or Checkbox from the UI Extensions API. The tutorial emphasizes using **CheckoutExtension APIs** to store the input in the checkout object (perhaps using Storage API or metametadata which persists through checkout) and how that data can be retrieved post-order via the API or the app’s webhook.

The _Add a banner to checkout_ tutorial is similar but for non-interactive content. It shows creating a UI extension that displays a highlighted message box on, say, the top of the information step or above the shipping options. You might use a Banner component with style (info, warning, success, etc.) and static or dynamic text. For example, _“Please note: Holiday shipping may be delayed.”_ or _“You have a discount applied: SAVE10.”_ The tutorial covers selecting the right extension target (there are specific banner targets in checkout editor, or one can place a banner via a generic render-before or render-after target at certain sections).

There’s also _UX for fields_ which provides guidelines: e.g., keep custom fields concise, only ask necessary info, don’t duplicate info Shopify already collects, and ensure banners are meaningful and not too distracting[\[170\]](https://shopify.dev/docs/apps/build/checkout#:~:text=instructions%20to%20their%20order.%20Client,extension%20to%20customize%20the%20address).

Together, these guides let developers enhance checkout by **collecting additional customer input** (for merchant needs like gift messages, tax IDs in certain countries, etc.) and **displaying custom information** (announcements, promos, warnings) – all through the sanctioned extension points. They likely highlight that all custom fields must map to something (like a metafield definition on the Order or a cart attribute) so that the data is stored with the order for merchant reference, and that banners should be used sparingly to avoid clutter.

### Delivery and Shipping Customizations (Functions & Extensions)

Shopify Functions enable deep customization of shipping and delivery options in checkout. The _Delivery and shipping functions_ section introduces how apps can create Functions to, for example, provide custom shipping rates, modify delivery methods, or impose rules on shipping selections[\[175\]](https://shopify.dev/docs/apps/build/checkout#:~:text=Use%20a%20checkout%20UI%20extension,extension%20to%20customize%20the%20address). Specific tutorials include:

- **Convert additional address fields:** likely covers using Shopify’s shipping address rules (like converting a single “Address line 2” into distinct fields or mapping regional fields for carriers).
- **Build the delivery options function:** a step-by-step to create a Function that adds or changes delivery options at checkout (e.g., rename “Standard Shipping” to a custom label, or inject a new option like “Express Delivery by AppCo”). This function would use the Delivery Options API – taking cart data as input and returning a set of shipping options output.
- **Add configuration to your delivery options function:** shows how to add merchant-configurable settings to the Function (via a Function configuration UI). For example, the merchant could set a flat rate value or toggle an option on/off, which the Function reads via its functionSettings input[\[104\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=In%20this%20tutorial%2C%20you%27ll%20learn,to%20do%20the%20following%20tasks)[\[176\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=,can%20use%20to%20fetch%20data). This often involves defining a schema in the function’s TOML (e.g., a boolean or number setting) and possibly building an **Admin UI extension** (Function Settings UI) for it.
- **Build the UI for the delivery customization function:** likely refers to creating an admin UI extension in the Shopify admin (on the app’s settings page) for any _Function Configuration UI_ using Polaris Form components[\[104\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=In%20this%20tutorial%2C%20you%27ll%20learn,to%20do%20the%20following%20tasks). It might also refer to a checkout UI extension if some shipping functions need a front-end component (less common – shipping functions are backend).
- **UX for delivery options:** guidelines on naming shipping options clearly, not overwhelming customers with too many choices, and ensuring any custom logic (like date pickers) integrates smoothly.

Additionally: - **Create a local pickup charges function:** a tutorial for a function that adds an extra fee for local pickup at checkout (Shopify by default doesn’t charge for pickup, but a merchant might want to). - **Build a date picker for a specific shipping rate:** a combination of a UI extension (to pick a delivery date) and a Function (to maybe adjust availability or just store the date). This might demonstrate using a checkout UI extension on the shipping step that only appears when a certain shipping option is selected, letting customer choose a date, and then capturing that input. - **Generate pickup points:** a more advanced shipping function example where, given the customer’s address, the Function returns multiple “pickup point” options (addresses of pickup locations) as shipping options. It might integrate with an external API (if allowed via Functions with limited HTTP – note: Functions now support some HTTP requests via “DeliveryLocalization” but typically it’s done through predefined data). - **UX for pickup points** and **UX for delivery methods**: guidelines such as using recognizable names for pickup locations, not listing too many, perhaps sorting by distance, and ensuring the customer understands how to get their items. For delivery methods, maybe advice like show delivery times clearly, avoid surprise fees.

By implementing these, an app can highly tailor the shipping experience: e.g., a “Delivery Date” app might include a function that splits “Standard Shipping” into multiple date-specific options plus a UI to choose a slot, or a “Store Pickup Plus” app might add various pickup locations as shipping choices along with a map UI.

These guides emphasize combining **Functions** for logic with **UI Extensions** for interaction where needed, and instruct how to test these (likely via checkout on a dev store with the function deployed). They also highlight the **merchant configuration** aspect – many shipping customizations need to be adjustable by the merchant (like cutoff times, fee amounts), which is achieved through function config and admin UIs[\[104\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=In%20this%20tutorial%2C%20you%27ll%20learn,to%20do%20the%20following%20tasks)[\[176\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=,can%20use%20to%20fetch%20data).

### Customized Address Autocomplete (JavaScript Extension)

Shopify checkout by default uses an address autocomplete (for Plus merchants, Google Autocomplete is available). The guides **“Build customized address autocomplete”** and **“Format address suggestions”** show how a developer can override that with a custom address suggestion provider.

In _Build customized address autocomplete_, you likely create a **Checkout UI Extension (JavaScript)** that intercepts address input fields and provides suggestions from a custom source[\[177\]](https://shopify.dev/docs/apps/build/checkout#:~:text=extension%20to%20validate%20fields%20at,billing%20address%20forms%20in%20checkout). For example, an app might integrate a local postal service API for address validation or use an alternative provider (e.g., SmartyStreets or a proprietary database). The extension would use the AddressAutocomplete extension point or relevant APIs. Because it’s a JS extension (the link suggests ?extension=javascript), it might not rely on React but rather a low-level approach. It teaches how to capture the user’s input events and call an external API (the extension environment can fetch external resources if allowed via extension points). It also covers handling selection (when user picks a suggestion, filling the checkout address fields accordingly).

_Format address suggestions_ likely deals with how suggestions are displayed in the dropdown – for instance, formatting to “Street, City, Region, Country” or including certain details. It might allow customizing the suggestion item UI (maybe highlighting matching terms, etc.). It might also refer to adjusting the order or content of suggestions for better UX.

By implementing these, a developer can deliver an app that **provides region-specific address services** (like validating local postal codes or languages) beyond Shopify’s default. The guides ensure that the extension properly interfaces with Shopify’s address form (which is dynamic with country selection, etc.) and doesn’t break the form’s submission.

Also, they likely caution that any custom address service must be high-quality – address entry is critical for deliveries, so suggestions must be accurate. The _JavaScript_ extension context implies these cannot use React and must be careful with performance and script size (Shopify might allow a certain bundle size for this extension type).

### Product Offers (Pre- and Post-Purchase Upsells)

**Product offers** refer to upsell or cross-sell promotions an app can provide either **before checkout (pre-purchase)** or **after checkout (post-purchase)**. Shopify supports both via extensions: - **Pre-purchase offers**: using a **Checkout UI Extension** that appears in the order summary or as an interstitial during checkout, encouraging the customer to add another product before completing the order. - **Post-purchase offers**: using a **Post-purchase Extension** which appears after the customer pays but before the Thank You page, offering an additional item or upgrade that can be purchased in one click (this creates a separate order or adds to the existing order).

The _About product offers_ guide explains these opportunities and how they fit into checkout[\[178\]](https://shopify.dev/docs/apps/build/checkout/product-offers#:~:text=About%20product%20offers%20,Create%20cart). It likely notes that _pre-purchase_ offers show up on the checkout page itself (for Plus stores currently), while _post-purchase_ offers present a special page after payment. It emphasizes focusing on conversion and a smooth UX – e.g., an upsell should be relevant and not overly distracting such that it harms the main purchase conversion[\[179\]](https://shopify.dev/docs/apps/build/checkout#:~:text=Anchor%20to%20Checkout%20UI%20extensions,tutorialsCheckout%20UI%20extensions%20tutorials).

Tutorials: - **Build a pre-purchase product offer checkout UI extension**: This would guide adding a UI element in checkout (perhaps above the payment button) offering a product. It covers how to display product info (image, price, discount), and how to add it to the cart if accepted. It may use a **“addLineItem”** API available to checkout extensions for Plus. The extension likely listens for the customer clicking “Yes, add this to my order” and then calls an API to update the checkout’s cart lines (Shopify provides a method to do this in extension). The guide likely references using useApplyCartLinesChange or similar hook[\[179\]](https://shopify.dev/docs/apps/build/checkout#:~:text=Anchor%20to%20Checkout%20UI%20extensions,tutorialsCheckout%20UI%20extensions%20tutorials). - **Build a post-purchase product offer checkout extension**: This tutorial covers implementing a _Post-purchase_ extension. A post-purchase extension runs after payment authorization; it can show an upsell page with a timer or special deal, and if the customer accepts, it creates an order (charging the saved payment method automatically). The guide teaches how to structure that extension’s page, handle acceptance or decline, and how to test it using the CLI’s post-purchase testing flows[\[179\]](https://shopify.dev/docs/apps/build/checkout#:~:text=Anchor%20to%20Checkout%20UI%20extensions,tutorialsCheckout%20UI%20extensions%20tutorials) (the list at L204-212 indeed shows a link for “Post-purchase checkout extensions” and “Thank you and order status extensions”). - **Create a post-purchase subscription**: possibly a specific scenario where the upsell is converting the one-time purchase into a subscription (or adding a subscription contract). This might involve using the Subscription APIs or selling plan to create a subscription in the post-purchase. - **UX for pre-purchase product offers / UX for post-purchase product offers / UX for post-purchase subscriptions**: These guides provide best practices, like ensuring the offer is clearly beneficial, not using dark patterns, keeping the UI consistent with checkout, and for post-purchase, making it clear the initial order is confirmed regardless of upsell choice (so customers aren’t confused or feel tricked)[\[179\]](https://shopify.dev/docs/apps/build/checkout#:~:text=Anchor%20to%20Checkout%20UI%20extensions,tutorialsCheckout%20UI%20extensions%20tutorials).

The documentation likely underscores that **timing and relevance** are key: pre-purchase offers should load quickly and match the customer’s cart (e.g., an accessory for a product in cart), and post-purchase offers should be compelling but easy to dismiss without frustration. It also might mention that only one post-purchase extension can run per checkout (one app’s offer), so competition means your app should do one good offer. They also stress that offers must follow Shopify’s guidelines (no excessive discounts that undermine store policies, etc.) in order to be listed.

### Shopify Functions in Payments (Payment Customization Functions)

**Functions in payments** allow apps to customize aspects of the payment process in checkout. While earlier we discussed Payment _extensions_ (which are full payment gateways), here it refers to **Payment Functions** – a relatively new feature where Functions can conditionally hide/show or modify payment options. For example, a Payment Function could enforce _payment terms_ or dynamically decide which payment gateways to offer based on order criteria[\[180\]](https://shopify.dev/docs/apps/build/payments#:~:text=,information%2C%20refer%20to%20Payment%20authorization). The _About functions in payments_ likely introduces that you can write a Function to, say, hide “Cash on Delivery” if the order total is above a threshold, or to force splitting payment if certain items are present. It references adding configuration (like the function might have settings for which payment methods to affect)[\[181\]](https://shopify.dev/docs/apps/build/checkout#:~:text=Anchor%20to%20Shopify%20Functions%20tutorialsShopify,Functions%20tutorials).

Guides: - **Add configuration to the payments function**: similar to other functions, showing how to include merchant-adjustable settings for the payment function (maybe a threshold amount, or selecting which payment method to target). - **Create the payments function**: coding the Rust/JS function that receives payment gateways and returns a result possibly filtering them. (For instance, if certain conditions met, it can mark a payment method as unavailable or modify its label to “Unavailable for this order” with explanation.) - **Build the UI for the payment customization function**: if needed, an admin UI for the merchant to set the function’s config, or even a Checkout UI extension if the function requires collecting input (less common in payments – you typically don’t collect extra input at payment selection beyond what’s native). - **UX for payments**: guidelines like do not remove all payment options (always leave at least one), clearly communicate to customers why an option is disabled if you disable it (which Payment Functions can do via an error message), and maintain trust (messing with payment can confuse customers easily).

- **Set payment terms**: possibly about using the Payment Terms API to set net payment terms for draft orders or B2B orders via the app[\[180\]](https://shopify.dev/docs/apps/build/payments#:~:text=,information%2C%20refer%20to%20Payment%20authorization). Or it might refer to an extension that sets custom payment due dates (for B2B, net30, etc.). Since this is listed under checkout build, it could detail how an app can implement _payment terms agreements_ (like letting customers agree to pay later) as part of checkout. Payment terms usually apply outside of normal consumer checkout (for invoicing orders), but the doc likely covers how apps can manage them via Admin API.

The Payment Functions documentation is likely still evolving, but key is that _Functions for payments_ allow an app to **control payment visibility and behavior without creating a full payment gateway** – which is powerful for things like conditional payment method logic. Only Shopify Plus stores (or certain eligible ones) can use these currently, as indicated in the Payments extension doc (custom payment apps are limited to Plus)[\[182\]](https://shopify.dev/docs/apps/build/payments#:~:text=Note).

In summary, these guides let developers add **business rules to payments**: for example, “If order > $1000 and customer is not VIP, hide ‘Cash on Delivery’” could be done with a Payment Function plus config. It ensures merchants who install the app can trust that the appropriate payment methods show up for each scenario, improving risk management or compliance.

### Thank You and Order Status Page Customization

The **Thank You page** (order status page) is the final page after checkout, and Shopify apps can also extend this page using extensions. The _About Thank You and Order status page customization_ explains that after checkout, apps can display additional content – for example, a customer survey, loyalty program signup, referrals prompt, or product recommendations. It’s a good place to engage customers once the purchase is done.

Shopify provides **Order Status page extensions** (which can show content either to all customers on thank-you, or specifically to logged-in customers in the account context). The docs mention building a survey extension as a common use case[\[183\]](https://shopify.dev/docs/apps/build/checkout#:~:text=Pre,44%2015%20Header). Indeed, the tutorial _Add a survey to Thank You and Order status pages_ walks through creating an extension that shows, say, a “How did you hear about us?” survey with a few options after checkout[\[183\]](https://shopify.dev/docs/apps/build/checkout#:~:text=Pre,44%2015%20Header). This extension runs on the thank-you page and can capture the response (likely via an App Proxy or sending it to the app’s backend, since the checkout is complete so a function is not involved – it might use a simple fetch to app backend or a pixel to record answers). It uses Checkout UI Extension points for the order status page.

Additionally, if the app deals with order-specific information (like delivery updates or digital downloads), it could use this extension point to provide those immediately.

For _UX_, they likely advise to keep post-checkout content **optional and lightweight** – the customer should easily find their order confirmation and not be overwhelmed. Anything shown should either add value (like a discount code for next purchase, or important info about their order) or gather feedback without being intrusive.

### Chat Integration in Checkout

**Chat applications** can now be integrated into the Order Status (thank-you) page via a Chat UI extension. _About chat applications_ describes that a chat app (like a support chatbot or WhatsApp integration) can appear in the post-checkout page to let customers ask questions about their order or get assistance[\[184\]](https://www.colorandcode.com/shopify-novelties/shopifys-latest-checkout-extensions#:~:text=Shopify%27s%20Latest%20Checkout%20Extensions%20,time). The _UX guidelines for chat_ will caution to use chat in a helpful way – e.g., pre-fill a message like “Hi, I have a question about order #1234…” or ensure the chat widget doesn’t obscure order details[\[184\]](https://www.colorandcode.com/shopify-novelties/shopifys-latest-checkout-extensions#:~:text=Shopify%27s%20Latest%20Checkout%20Extensions%20,time). It may also remind that chat on the thank-you page can be context-aware (some apps know the order details and customer info to provide personalized help).

The integration is likely achieved through a _Checkout UI extension for Order Status page_ that loads an iframe or SDK of the chat provider. The guidelines emphasize not to degrade the page performance and to adhere to privacy (only load after user consent if needed, etc.). For example, if implementing a survey or chat, wait a second or two after page load or on user clicking a chat icon, rather than immediately popping open.

### Localization of Checkout UI Extensions

**Checkout UI extension localization** allows developers to provide translations for any text their extension displays, to support multiple languages in checkout. The _About checkout UI extension localization_ explains that since checkout may be in various languages (Shopify supports multi-language stores), your extension should detect the checkout’s language and show content accordingly. The _Localize a checkout UI extension_ tutorial likely guides adding locale JSON files (for example, an en.json, fr.json in the extension bundle) and using the extension API’s i18n utility to get the right strings[\[177\]](https://shopify.dev/docs/apps/build/checkout#:~:text=extension%20to%20validate%20fields%20at,billing%20address%20forms%20in%20checkout). Shopify CLI likely helps by scaffolding a default en.default.json. The guide would have you add other languages and then test by switching the checkout’s language in a dev store to see the extension text change.

They emphasize using **Shopify’s provided localization framework** – do not hard-code one language or do your own detection. The extension receives the shop’s locale and you simply provide translated keys. This ensures a cohesive experience for international customers.

### Testing Checkout Extensions

The _Test checkout UI extensions_ guide provides tips and steps for testing your checkout customizations safely. It covers using the shopify app dev --checkout-cart-url command to generate test checkouts with specific items quickly[\[151\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=If%20you%20receive%20the%20error,a%20checkout%20session%20for%20you)[\[152\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=%24), using development stores with the Checkout Extensibility preview enabled, and possibly using **Checkout simulators** in the Partner Dashboard. It also mentions how to simulate different customer scenarios (e.g., logged in vs guest, various addresses) to ensure your extension behaves correctly.

It addresses common issues: for instance, if your extension doesn’t appear, check that the dev console query string is added or that the extension is correctly registered in the config. If you get a “property token” error, use the --checkout-cart-url method[\[151\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=If%20you%20receive%20the%20error,a%20checkout%20session%20for%20you). If the preview link isn’t showing, ensure you have a product in cart and you’re logged into the right store[\[185\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=Anchor%20to%20Missing%20checkout%20linkMissing,checkout%20link). The guide might also mention how to test post-purchase flows (which require completing a test payment – often done with a bogus gateway on a dev store – to see the post-purchase page).

It stresses testing on all relevant browsers/devices and making sure performance is good (checkout has strict performance budgets). For multi-step flows or multi-page extensions, test navigation and ensure state carries over.

### UX Guidelines for Checkout Extensions

**UX for checkout** is a best-practices document summarizing all the UX tips across checkout extension types. It likely includes: keep content concise (space in checkout is limited), don’t overwhelm or distract the buyer from completing purchase, align with Shopify’s design (use Polaris or provided components for consistency), ensure your extension loads fast (it should not noticeably delay checkout), and follow conditional logic if needed (only show when relevant to the user or cart). For validations: error messages should be clear and polite. For offers: value should be obvious and acceptance simple. For additional fields: only ask necessary info and explain why it’s needed (to avoid cart abandonment). Also, any **upsells or cross-sells** should not feel spammy – ideally they complement the purchase.

The guide probably also warns about mobile layouts – your extension must be responsive and usable on mobile screens (since many customers checkout on mobile). It might mention accessibility: any extension UI should be keyboard-navigable and readable by screen readers (extending Shopify’s commitment to accessible checkout) – which ties to the Accessibility best practices in another section[\[186\]](https://shopify.dev/docs/apps/build/accessibility#:~:text=Anchor%20to%20Keyboard%20and%20gesture,controlsKeyboard%20and%20gesture%20controls)[\[187\]](https://shopify.dev/docs/apps/build/accessibility#:~:text=Anchor%20to%20Keyboard%20supportKeyboard%20support).

### Multi-Page Extensions in Checkout

**Multi-page extensions** allow a Checkout UI extension to create a flow that spans multiple screens within checkout (for instance, a questionnaire that’s too long for one screen, or a stepped configuration). The _Create multi-page extensions_ guide presumably shows how to use the extension API’s navigation features – for example, using stepper or navigation.navigateTo to push a new page in the checkout UI extension container. It might illustrate creating a mini “wizard” inside checkout.

However, developers are cautioned to minimize friction – every extra step is an opportunity for drop-off. Use multi-page only if truly necessary (e.g., configuring a complex product directly in checkout, or filling a form that logically breaks into steps). The guide likely covers maintaining state between pages and returning to previous steps if needed.

## Building Apps for Customer Accounts (New Customer Account Extensions)

### Customer Accounts (Overview & Extensions)

Shopify’s new customer accounts (both **pre-auth** and **post-auth** experiences) allow apps to embed in customer-facing account pages. The _Building apps for customer accounts_ overview explains that merchants can offer a **customized account portal** to their customers, and apps can contribute features there – for example, a loyalty program app showing points balance, or an order tracking app providing return labels.

Shopify divides account extensions mainly into: - **Full-page extensions**: your app can provide entire new pages in the account menu (e.g., “My Rewards” page). - **Inline extensions**: small components embedded in existing core pages (e.g., an element on the Orders detail page, or on the account home). - **Order action extensions**: add actions in the context of an order (like a button to trigger a return or warranty claim). - **Pre-auth order status extensions**: components on the order status page (visible even if not logged in, similar to thank-you page extension). - **Editor extension collections**: a concept for grouping multiple extension points for ease of merchant enabling (for example, enabling a set of account extensions together).

And additional topics like writing to metafields from account extensions, localizing them, etc.

### Start Building for Customer Accounts

This guide likely mirrors the checkout quickstart but for customer accounts. It covers enabling the _Customer Accounts developer preview_ on a dev store, using shopify app generate extension to scaffold an account extension, choosing extension type (maybe “customer_accounts_ui” or specific target templates), and previewing in the customer account preview URL. Possibly instructs how to create a test customer, login, and see the extension.

It ensures CLI is up to date and explains that, like checkout, account extensions are deployed via app updates.

### Customer Account Extension Placement Decisions

**Decide on customer account UI extension placement**: explains each possible placement option: - Account home page, - Order list page, - Order detail page, - Account details/profile page, - etc. And for each, whether an **inline extension** vs a **full-page** extension suits. For example, if an app needs an entire page (like an embedded app page for managing subscriptions), then a full-page extension is appropriate. If it just adds a widget (like referral code on account overview), an inline extension is better.

This guide helps developers plan which extension type to build for their app’s function in accounts.

### UX for Customer Accounts

Guidelines specific to account pages: ensure your extension matches account design (which is typically simple and clean), do not confuse navigation – e.g., full-page extensions should clearly indicate what they are and how to go back. If listing information (like loyalty points transactions), format it similarly to how orders are listed (for consistency). Also, performance – account pages should load quickly. Possibly advise to not require heavy third-party scripts that could slow the account portal.

### Order Status Page (Pre-auth vs Post-auth)

“About the Order status page” likely clarifies difference: The Order Status page (Thank you page) can be shown to both guests and logged-in customers, and it’s a spot where both **checkout extensions** and **customer account extensions** might interplay. Pre-auth order status extensions are a special case of account extension that show info on that page without requiring login (like tracking info or upsells).

### Inline Account Extensions (Examples)

**About inline UI extensions** explains that _inline extensions_ appear within existing pages. They are smaller blocks, not full-page. E.g., an inline extension on the order history could be a “Reorder” button on each order, injected by an app[\[188\]](https://shopify.dev/docs/apps/build/flow#:~:text=Shopify%20Flow%20is%20an%20app,such%20as%20triggers%20and%20actions)[\[189\]](https://shopify.dev/docs/apps/build/flow#:~:text=Extension%20type%20Description%20Example%20Trigger,account%20that%20placed%20the%20order). Or on profile page, an inline extension could show a custom loyalty points balance next to the customer’s name.

The **Build an inline order status UI extension** and **Build an inline profile UI extension** tutorials provide concrete steps: - _Order status inline extension_: perhaps adding a widget on the post-checkout status page, like “Track your shipment” with a tracking link or “Join our newsletter” prompt. - _Profile inline extension_: maybe adding a form on the profile page for additional info (like account preferences) managed by the app.

They illustrate retrieving necessary customer data via the extension API (for logged-in context, you might get customer ID or order data passed in). And they show writing results somewhere (maybe calling the app backend to save preferences).

### Pre-auth Order Status Extensions

**Pre-auth** means the extension is visible on the order status page even if the customer is not logged into an account. The guide _About pre-auth order status UI extensions_ introduces that capability: apps can show content on the thank-you page for all customers. “Build pre-auth order status page extensions” tutorial would demonstrate adding something like a marketing offer or referral widget on the thank-you page using an extension targeted for that context. Because it’s pre-auth, it cannot rely on knowing the customer’s account identity (they might not have one); it might rely on order data only.

This requires caution that anything displayed contains no sensitive info (anyone with link can see it), and likely these extensions are more promotional or generic in nature.

### Order Action Menus in Accounts

**Order action extensions** allow adding new actions to each order in the customer’s account (similar to admin’s order actions but on storefront). The _About order action menus_ explains customers could, for example, click “Request Return” or “Extend Warranty” on an order, powered by an app. The _UX for order actions_ suggests to label actions clearly and perhaps only show them when applicable (e.g., hide “Return” if outside return window).

“Build for order action menus” tutorial would cover how to create an extension that registers a new action in the orders list or detail page. It would handle the click event – possibly opening a modal or redirecting to the app (if more complex UI needed). For a simple case, clicking could initiate some process via API and then show confirmation. The extension must use the Order data (passed via extension arguments) to know which order to act on.

### Full-Page Extensions (New Pages in Accounts)

**Full-page extensions** let an app introduce entirely new pages accessible via the account menu. _Add pages to customer accounts_ explains the concept: merchants can get a new navigation item which loads the app’s page. Examples: a “Subscriptions” page, “Loyalty Rewards” page, “Support Tickets” page, etc. These are analogous to embedded app pages but on the storefront side.

“Build new pages in customer accounts” tutorial likely shows scaffolding a full-page extension. The extension can use Polaris components (which are styled for storefront context) and GraphQL Storefront API or app proxy calls to fetch data. It might, for instance, display all loyalty points transactions by querying the app’s backend via an authenticated fetch (the extension has customer JWT or session token to call app backend). Or it could use Storefront API to fetch additional Shopify data if needed.

The guide would include how to set up navigation – maybe adding an icon or adjusting the default menu label in shopify.extension.toml. Also testing how it appears in the account menu.

**UX for full pages** advises making it fit seamlessly: use headings and layout similar to Shopify’s default pages, ensure page loads quickly, and provide a clear purpose (don’t add pages for trivial things).

### Metafield Access in Customer Accounts

**Building metafield writes into extensions** is likely a guide on how customer account extensions can read/write customer or order metafields. For example, a profile extension might allow the customer to fill additional info (metafields on Customer resource). It covers using Storefront API or App proxy to update metafields, since direct metafield writing might require GraphQL Admin API which isn’t directly accessible from a storefront extension (thus a proxy to app backend is used). They probably provide a simple sample: e.g., letting customer opt into marketing preferences (stored as a metafield) with a toggle, showing how the extension calls the app, the app uses Admin API to save metafield, and then extension updates UI.

### Editor Extension Collections

“Editor extension collections” might be a concept where an app groups multiple extensions under one toggling in the theme editor or accounts editor for simpler enabling. The _Editor extension collections_ guide likely outlines how an app developer can define a set of extensions that should be enabled/disabled together. It may specifically apply to Online Store theme app extensions, but since it’s listed under accounts, perhaps accounts also have an editor interface where merchant can toggle certain app sections collectively.

The _UX guidelines for editor extension collections_ would ensure consistency in naming, description, and not overwhelming the merchant with too many separate toggles. If an app provides, say, 3 small extensions for accounts (maybe one on account home, one on orders, one on profile), a collection could allow one switch to turn all on/off, which is simpler.

“Build an editor extension collection” tutorial would show how to define such a collection in the app’s configuration, grouping related extension points under one heading visible to the merchant.

### Localizing Customer Account Extensions

Similar to checkout, account extensions should support multiple languages. _About localizing customer account UI extensions_ and _Localize a customer account UI extension_ give the process of including translation files and using i18n APIs. Likely exactly like checkout extensions: include locale JSON, use provided hooks to get current locale and translated strings.

### Testing Customer Account Extensions

_Test customer account UI extensions_ would instruct how to preview and test account extensions. This might involve enabling the developer preview, logging in as a customer on the dev store, and adding a special query param or header to see draft extensions. Possibly Shopify CLI’s dev server will serve account extensions to a development environment similar to checkout’s ?dev= method. It might mention how to test scenarios like new vs returning customers, or different devices.

All in all, the customer accounts documentation equips developers to extend the _authenticated customer experience_ on Shopify storefronts, much like how admin extensions extend the merchant experience. It’s a new area (currently in developer preview), so thorough testing and following Shopify’s design cues is crucial to maintain trust and usability for customers using their accounts.

## Shopify Flow Integration (Workflow Automation Extensions)

### About Flow

**Shopify Flow** is an automation tool (Shopify app) that lets merchants create workflows (if-this-then-that style) to automate tasks across Shopify and apps. The _About Flow_ page explains that Flow provides triggers (events), conditions, and actions that can be chained into workflows[\[188\]](https://shopify.dev/docs/apps/build/flow#:~:text=Shopify%20Flow%20is%20an%20app,such%20as%20triggers%20and%20actions)[\[190\]](https://shopify.dev/docs/apps/build/flow#:~:text=Anchor%20to%20Why%20build%20for,FlowWhy%20build%20for%20Flow). As a developer, you can extend Flow by providing **custom triggers** (events from your app) and **custom actions** (actions your app can perform) that merchants can use in their workflows[\[188\]](https://shopify.dev/docs/apps/build/flow#:~:text=Shopify%20Flow%20is%20an%20app,such%20as%20triggers%20and%20actions)[\[191\]](https://shopify.dev/docs/apps/build/flow#:~:text=Extension%20type%20Description%20Example%20Trigger,00%2C%20then). For example, a reviews app could supply a trigger “Review created” and an action “Send review to Slack” – merchants could build a workflow: _When a review is created (trigger from app) -> If rating &lt;= 2 (Flow condition) -&gt; Then send a Slack message (action from app)_[\[192\]](https://shopify.dev/docs/apps/build/flow#:~:text=Building%20for%20Flow%20can%20help,integrating%20with%20Flow%2C%20you%20can)[\[193\]](https://shopify.dev/docs/apps/build/flow#:~:text=have%20a%20review%20app,integrating%20with%20Flow%2C%20you%20can).

The _About Flow_ doc highlights **why integrate**: it increases your app’s utility and visibility. Merchants get more value because your app can seamlessly connect with other apps and Shopify features via Flow workflows[\[190\]](https://shopify.dev/docs/apps/build/flow#:~:text=Anchor%20to%20Why%20build%20for,FlowWhy%20build%20for%20Flow)[\[194\]](https://shopify.dev/docs/apps/build/flow#:~:text=,the%20%2026%20Flow%20app). It also notes that apps working with Flow get a special badge on the App Store and can appear in Flow’s template library, potentially boosting adoption[\[195\]](https://shopify.dev/docs/apps/build/flow#:~:text=similar%20value%20to%20your%20merchants,the%20%2026%20Flow%20app).

### Flow Development and Extension Types

_About Flow development_ likely details how to build these extensions. Flow extensions are defined via the Partner Dashboard or config files as _Flow Trigger Extensions_ and _Flow Action Extensions_. They require specifying schemas for data (input/output), building an endpoint on your app to handle the action (Flow will send an HTTP request to your app when the action runs), or to emit a trigger event (your app calls a Flow API when your event occurs).

The doc outlines considerations: triggers should be meaningful business events, not too frequent (to avoid overloading Flow), and actions should be idempotent and confirm success/failure. It also mentions testing using the Flow _Test_ feature and observing execution logs.

### Flow Triggers

_About Flow triggers_ and the tutorial _Create a Flow trigger_ explain how to implement a custom trigger. You typically define a trigger’s name, description, and data schema (what data fields it provides to workflows)[\[189\]](https://shopify.dev/docs/apps/build/flow#:~:text=Extension%20type%20Description%20Example%20Trigger,account%20that%20placed%20the%20order). For example, trigger “Review Created” might provide fields: review content, rating, product, reviewer email, etc. Then, in your app’s code, when that event happens, you call the Shopify Flow API endpoint to notify Flow, causing workflows listening on that trigger to start.

The guide likely emphasizes to call Flow _quickly after the event occurs_ so workflows run in near real-time, and to handle any API errors (perhaps logging if Flow isn’t installed or if the merchant disabled your extension).

They also mention triggers can include a _sample payload_ for merchants to see when building workflows, and advise how to design the trigger such that it’s broadly useful (maybe include enough info so merchant can use Flow conditions on it effectively, like providing a numeric rating value so they can set “if rating <= 3”).

The _Flow trigger reference_ probably lists all built-in triggers and how custom triggers integrate (this may be a reference for the JSON schema definition etc.).

### Flow Actions

Similarly, _About Flow actions_ and _Create a Flow action_ cover building an action extension. You define the action (name, description, input properties the merchant must provide or that come from trigger context)[\[191\]](https://shopify.dev/docs/apps/build/flow#:~:text=Extension%20type%20Description%20Example%20Trigger,00%2C%20then)[\[196\]](https://shopify.dev/docs/apps/build/flow#:~:text=total%20amount%20paid%20for%20the,account%20that%20placed%20the%20order). For instance, an action “Reply to Review with coupon” could take an input: discount percentage, and the trigger’s review email.

When a workflow runs that uses your action, Shopify Flow will send an HTTP POST to your app’s specified action endpoint (including identifiers and inputs). Your app must perform the action (e.g., generate a discount code and email it) and respond with success/failure. The doc likely advises making actions idempotent (in case Flow retries the call) and reasonably quick to respond (though some actions may be async by nature).

The _Flow action reference_ and _Create Flow action endpoints_ provide details on the exact request format your app receives and how to structure responses. Possibly mention security (Shopify signs the requests with a HMAC or uses OAuth token; you should verify the call is from Shopify).

### Flow Action Configuration UI

_Build the configuration UI_ guide shows how to create the admin UI for configuring your Flow action if needed. Some actions might have static config via the input fields in workflows (which the merchant sets each time they use the action in a workflow). Others might require app-level config (less common for Flow actions – usually each usage can define its parameters).

Potentially, if an action needs OAuth to a third-party, etc., the config UI could help link that. But likely this section might not be heavily used.

### Flow Templates

**Flow templates** are pre-built workflows that merchants can install with one click. _About Flow templates_ and _Create a Flow template_ explain that as an app developer, you can publish workflow templates demonstrating use of your triggers/actions[\[197\]](https://shopify.dev/docs/apps/build/flow#:~:text=Anchor%20to%20TemplatesTemplates)[\[198\]](https://shopify.dev/docs/apps/build/flow#:~:text=A%20template%20in%20Shopify%20Flow,and%20help%20merchants%20do%20more). For example, “Notify customer when their review gets a reply” or “Auto-tag customer as VIP after 3 orders” if your app offers the action to tag customers. Templates make it easier for merchants to discover and use your app’s Flow integrations without building from scratch.

The docs likely tell how to define a template (JSON or through Partner UI), including metadata like title, description, and the workflow JSON itself referencing your app’s extensions. The _Flow template reference_ might list example templates or required fields.

This is great for marketing – your app appears in Flow’s template library under relevant categories. The doc reminds to focus on valuable, common use-cases in templates.

### Tracking Flow Lifecycle Events

The _Track Flow lifecycle events_ guide may instruct how your app can monitor usage of its Flow extensions – e.g., knowing when a merchant installs/uninstalls your Flow triggers and actions, or when workflows using them execute. Possibly via webhook: Shopify could send a “flow/trigger_executed” webhook to apps or similar.

It might also be about logging within your app when your trigger was fired or your action called, to have an audit trail.

### Complex Data in Flow

_Configure complex data types_ likely refers to how to handle more complex inputs/outputs in Flow triggers/actions. Flow supports basic types (string, number, boolean, etc.) and arrays/objects. If your trigger needs to provide an array of items or nested data (like an order with line items), the doc might explain how to structure that and how merchants can use it (Flow’s condition builder might not handle nested arrays except via text or counting). Or if your action needs a list of IDs, how to accept that.

The guidance is probably to simplify wherever possible (to not confuse merchants) and maybe to flatten or provide key relevant fields rather than deeply nested structures.

### Migrating Legacy Flow Integrations

_Migrate legacy Flow extensions_ suggests if you had an older integration (Flow used to allow private triggers/actions configured via Partner Dashboard JSON), you might need to move to the new format or CLI-based config. It outlines steps to update to the latest Flow extension framework.

In summary, the Flow docs provide everything to integrate **your app into Shopify’s automation engine**, unlocking advanced cross-app functionality for merchants and potentially increasing your app’s stickiness (once they build flows with it, they’ll keep your app around)[\[192\]](https://shopify.dev/docs/apps/build/flow#:~:text=Building%20for%20Flow%20can%20help,integrating%20with%20Flow%2C%20you%20can)[\[194\]](https://shopify.dev/docs/apps/build/flow#:~:text=,the%20%2026%20Flow%20app).

## Apps in the Online Store (Storefront Integrations)

### Online Store App Integrations (Overview)

**Apps in the online store** relates to how apps can extend the storefront (the theme) and product content. Historically, this included things like script tags and asset API, but now primarily **Theme App Extensions** and **App Proxies** are used. The _Apps in the online store_ overview likely describes ways an app can: - Embed dynamic content into a merchant’s theme without manual theme code edits (via **Theme App Extensions**). - Serve dynamic pages or data to the storefront through an **App Proxy**. - Manage product media (like adding images/videos to products via API). - (Legacy) Use ScriptTag API or Asset API – which are now deprecated or being phased out for most cases[\[199\]](https://shopify.dev/docs/apps/build/checkout#:~:text=Apps%20in%20checkout,Shopify%20checkout%20with%20new)[\[200\]](https://shopify.dev/docs/apps/build/checkout/styling#:~:text=About%20checkout%20styling%20,Create%20cart).

It emphasizes using new extension methods because they are safer and easier for merchants (no theme code breaks on uninstall, etc.).

### App Proxies (Dynamic Store Data)

**App proxies** allow an app to provide dynamic content at a storefront URL path (like /apps/your-app/page) which is rendered as part of the shop’s domain. The _Display dynamic store data with app proxies_ guide explains setting up a proxy in the Partner Dashboard (choose a sub-path and target URL on your app’s server). Then, when a customer visits that URL on the store, Shopify proxies the request to your app and returns the response under the store’s domain[\[199\]](https://shopify.dev/docs/apps/build/checkout#:~:text=Apps%20in%20checkout,Shopify%20checkout%20with%20new). This is used for things like custom forms, calculators, or pages that need to display data from the app while maintaining shop domain (for SEO or cookie reasons). The doc shows how to handle proxy requests (with HMAC verification and possibly including Shopify-specific parameters like logged_in_customer_id if session exists).

It likely provides a simple example: maybe an app that shows a customer’s loyalty points as a page. The app can receive the proxy request with the customer’s ID (if logged in) and then respond with an HTML snippet or JSON which the theme can render.

One must ensure the response is quick and formatted correctly (if content type is JSON, maybe it’s used by AJAX; if HTML, directly rendered). The doc also warns that for SEO-critical pages, ensure caching as appropriate because proxies are dynamic.

### Theme App Extensions

**Theme app extensions** let apps deliver **Liquid, CSS, and JavaScript** in modular chunks that a merchant can easily add to their theme via the theme editor. The _About theme app extensions_ guide outlines that instead of having apps edit theme code directly, they package their code as an extension. Merchants can then add an app block or section where desired in the theme customizer[\[200\]](https://shopify.dev/docs/apps/build/checkout/styling#:~:text=About%20checkout%20styling%20,Create%20cart). This sandboxing means uninstalling the app automatically removes its code, and multiple themes can have the app UI separately configured.

The _Build theme app extensions_ tutorial covers scaffolding a theme extension (likely creating a snippets/\*.liquid or sections/\*.liquid in an assets/ folder of the extension, plus any CSS/JS needed). It may instruct how to use **Liquid variables** made available to the extension (some shop info, or any app block settings). It then shows how to deploy it via shopify app deploy and how a merchant would add it in the theme editor.

UX wise, _UX for theme app extensions_ suggests that app blocks should **blend with theme styling** (maybe inherit fonts/colors by default, or provide customization options via block settings). They should be responsive and not break layout. They should also handle if multiple instances are added (don’t rely on a single global script without unique context if multiple blocks can be used).

### Theme App Extension Configuration

_Configure theme app extensions_ likely covers how to define settings for your app block/section (in a schema in Liquid). For example, a map app block might let merchant choose map type or zoom via settings in theme editor. You specify these in your extension’s Liquid schema so merchants can customize when adding the block.

It may also mention how to implement translations for text in Liquid, though theme localization can handle that.

### Migrating from Legacy Theme Integrations

_Migrate to theme app extensions_ provides steps for apps that used to inject code via script tags or asset uploads to move to the official extension system[\[200\]](https://shopify.dev/docs/apps/build/checkout/styling#:~:text=About%20checkout%20styling%20,Create%20cart). It likely encourages doing so because Shopify will _block ScriptTag injection in future (as noted by the “blocking script tags” link)_[\[201\]](https://shopify.dev/docs/apps/build/checkout#:~:text=Apps%20in%20checkout%20,Shopify%20checkout%20with%20new). It might outline: remove old code injection, create theme extension snippet with same functionality, use app blocks instead of instructing merchants to edit theme.

### Verify Theme Support

_Verify theme support_ suggests ways to detect if a given theme supports a certain app feature or if any adjustments needed. Possibly refers to ensuring the theme has a matching layout/section where your app block can be inserted, or checking if theme is outdated. Or verifying theme is Online Store 2.0 (which is required for theme app blocks).

It could be a guide to programmatically check theme compatibility and warn merchants if not (some older vintage themes might not easily support app blocks).

### Managing Product Media via Apps

**Manage media for products / variants** covers how apps can upload and attach media (images, 3D models, videos) to products or variants through APIs. For example, a 3D modeling app could add a 3D model to the product gallery. The doc likely details using the GraphQL or REST Admin API endpoints: creating a Media object (like model3d or video with a URL, etc.), or the newer GraphQL productCreateMedia mutation.

It will also mention that apps should host media externally or use Shopify’s new **Files API** to upload and get a URL. Managing variant media similarly.

### Legacy: ScriptTag and Asset APIs (Deprecated)

There are references to _ScriptTag functionality to be blocked as of Feb 1, 2025_ and _ScriptTag resource (legacy)_[\[201\]](https://shopify.dev/docs/apps/build/checkout#:~:text=Apps%20in%20checkout%20,Shopify%20checkout%20with%20new). These indicate that Shopify is phasing out the ScriptTag API for injecting scripts into storefront (likely for performance and security reasons). The docs would warn that apps should move to theme extensions or app blocks, as any script tags injected into theme will stop working on that date. The _Asset API resource (legacy)_ similarly refers to the old method of directly editing theme files (like injecting code in theme.liquid). It’s now discouraged – plus with Online Store 2.0, merchants might update themes and lose those changes.

The documentation for these legacy topics likely just provides info for maintenance of older apps but strongly recommends migrating to the new mechanisms. Specifically, the ScriptTag blocking announcement is crucial – any app still relying on ScriptTag to add store scripts (like chat widgets, analytics, etc.) must switch to either a theme app extension or an alternative injection method that Shopify approves (possibly pixels for analytics).

In summary, the Online Store integration docs highlight **modern, safer ways** for apps to extend storefronts (theme app extensions for UI, app proxies for dynamic content) and caution against older approaches which are being deprecated[\[201\]](https://shopify.dev/docs/apps/build/checkout#:~:text=Apps%20in%20checkout%20,Shopify%20checkout%20with%20new)[\[200\]](https://shopify.dev/docs/apps/build/checkout/styling#:~:text=About%20checkout%20styling%20,Create%20cart).

## Apps in Point of Sale (Retail Store Integrations)

### Shopify POS (Overview of App Opportunities)

**Apps in POS** covers how apps can integrate with Shopify’s Point of Sale app used by merchants in physical stores. The POS offers **embedded app components** and **extension points** in the POS interface where apps can add functionality (for example, loyalty point redemption at checkout, custom discount logic, etc.). The doc likely explains that POS is a separate channel with its own extension SDK (Shopify POS App Extensions).

The _Embed your app in POS_ guide describes how an app can appear as a tile in the POS smart grid (the home screen), and how it can embed UI during the checkout flow or in the cart. It covers setting up your app to recognize POS context and possibly using the POS App Bridge library to communicate (similar to App Bridge for admin but for POS).

It also touches that POS apps must be installed through Shopify like any app, but to use in POS, the merchant assigns it to their POS devices via staff permissions or POS app management.

### POS UI Extensions

Shopify has **POS UI Extension** types for specific features: - **Discount UI extension**: an app can provide a custom discount interface in the POS checkout (e.g., scan a loyalty card to apply a custom discount). - **Print UI extension**: an app can hook into receipt printing flow (maybe to print a custom coupon or additional info on the receipt). - **Loyalty extension**: likely an extension point for loyalty/rewards redemption within POS cart.

The guides _Build a discount UI extension_, _Build a print UI extension_, _Build a loyalty extension_ (with extension=react as the example) walk through implementing these. They involve building a small React app that runs inside the POS app on an iPad at specific trigger points: - The discount extension might show up when the cashier taps “Apply App Discount” and then your app UI collects input (like loyalty points usage) and returns a discount amount to apply to the cart[\[202\]](https://community.shopify.com/c/shopify-apps/can-you-create-and-run-multiple-extensions-for-one-app/td-p/1945438#:~:text=Display%20multiple%20apps%20in%20checkout,). - The print extension likely integrates when printing receipts – maybe allowing an extra page or customizing the printout with a QR code or survey link. The tutorial could involve formatting a small print template via HTML or data that gets merged. - The loyalty extension likely displays during cart review, showing customer’s loyalty status and enabling adding rewards to the cart.

Because POS doesn’t run a browser in the same way, these extensions might rely on a **POS Extension SDK** where your code runs in a Web Worker or similar environment. The docs instruct how to test these (Shopify has a POS simulator or you test on actual device in dev mode).

Each tutorial emphasizes a good UX: e.g., **Discount extension** should fail gracefully if e.g. loyalty points are insufficient, and should present clear confirmation of discount applied[\[202\]](https://community.shopify.com/c/shopify-apps/can-you-create-and-run-multiple-extensions-for-one-app/td-p/1945438#:~:text=Display%20multiple%20apps%20in%20checkout,). **Print extension** should ensure it fits on receipt and doesn’t slow the print process significantly. **Loyalty extension** should be quick to use at checkout (retail checkout needs to be fast).

### POS UI Extension Reference

_POS UI extensions API reference_ would list all available extension points and API methods. For example, an API to apply a discount to cart, an API to fetch current cart items, an API to prompt for scanning a barcode (POS devices can scan codes and pass data to app), etc. The documentation of extension points (like cart.decorations, paymentOptions, etc.) would be important.

### Legacy POS Integrations

Shopify had older ways for POS like _POS links (legacy)_ which were basically a URL schema to open the Shopify POS app to certain pages, and _POS cart app extensions (legacy)_ and _POS product recommendations (legacy)_ which might refer to earlier incarnations of POS app elements. These are likely deprecated now in favor of the official extension SDK. The docs might still mention them for context or if some merchants still on old POS.

For example: - _POS links (legacy)_: maybe an older way where POS would show web links in the app. - _POS cart app extensions (legacy)_: Possibly a way to push info to POS cart screen before the new Extensibility. - _POS product recommendations (legacy)_: maybe older API to show an app’s upsell in the product details in POS.

They are probably no longer supported on the new POS (Shopify’s new POS app uses only extension SDK). The documentation likely guides migrating to the new extension framework.

In short, the POS docs highlight that apps can now **seamlessly integrate into the in-store selling experience**, similarly to how they integrate into admin or online store, but with retail-specific use cases (loyalty, custom discounts, printing, etc.). It underscores performance and reliability because store staff will be using this in front of customers. The new POS extension model is more robust than old hacky methods, ensuring the app can be an integrated part of checkout or the POS workflow without manual app switching[\[202\]](https://community.shopify.com/c/shopify-apps/can-you-create-and-run-multiple-extensions-for-one-app/td-p/1945438#:~:text=Display%20multiple%20apps%20in%20checkout,).

## Working with Shopify APIs (GraphQL vs REST, Migration Guides)

### GraphQL vs REST (API Paradigm Shift)

Shopify encourages using the **GraphQL Admin API** for new development due to its efficiency and new features. The _About GraphQL_ guide introduces GraphQL basics and how Shopify’s GraphQL Admin API works (it’s a versioned endpoint, uses queries and mutations, etc.). It likely lists advantages: you can fetch exactly the fields you need, combine multiple data queries in one round-trip, and GraphQL gets new capabilities sooner than REST[\[203\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=Start%20building%20for%20checkout%20,Create%20cart).

The next pages: - **GraphQL queries**: examples of retrieving data (like querying products, orders) and how to structure queries with nested fields[\[203\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=Start%20building%20for%20checkout%20,Create%20cart). - **GraphQL mutations**: how to modify data (create, update, delete operations) with GraphQL syntax and that they return objects including errors that occurred. - **GraphQL variables**: showing how to parameterize queries/mutations so you don’t have to concatenate dynamic values into the query string (important for sending data like IDs, etc.). - **Advanced concepts**: possibly GraphQL edges and connections (how Shopify uses cursor-based pagination), how to handle throttling (GraphQL cost credits), and maybe using aliases/fragments.

These guides ensure developers unfamiliar with GraphQL can get up to speed on making API calls to Shopify. They show examples converting a typical REST request to GraphQL. For instance, instead of GET /products, you do a GraphQL query for products { edges { node { id title } } }.

### Migration from REST to GraphQL

Shopify provides migration guides for those with REST-based apps: - **About REST to GraphQL migration**: explanation of why migrate (performance, new features only on GraphQL like bulk operations, etc.), and reassurance that most things possible in REST have an equivalent in GraphQL. - **Migrate to GraphQL from REST**: likely a breakdown resource by resource – e.g., if you used to call GET /admin/api/orders.json, now use orders GraphQL query. It might include common patterns (like how to use GraphQL Admin ID vs REST numeric IDs, since GraphQL uses a global ID format). - **Update API calls in your app (libraries)**: instructs how to use Shopify’s API libraries (e.g., Shopify API for Node) to work with GraphQL endpoints as well. Or if using REST library, how to adapt.

Then specific sections: - **Update your app to use the new files model** (the new Files API and GraphQL types for file attachments replaced older Media or Asset endpoints, so if an app used REST for images or themes, how to switch to GraphQL’s FileCreate, etc.). - **Using the latest GraphQL product APIs**: likely focusing on the **new Product variant model** introduced (Shopify has a new GraphQL schema for products as of 2023 – e.g., they moved variant inventory data into a unified InventoryItem model, etc.). It might mention new fields available in GraphQL like sellingPlan groups (for subscriptions) or new Metafield types. - **API updates (in new product model)** and **Product model and components**: detail changes in how products, variants, media, options, etc., are represented in the new GraphQL schema compared to the old one. They probably provide side-by-side: e.g., old way to get variant inventory vs new way with inventoryLevels connection[\[203\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=Start%20building%20for%20checkout%20,Create%20cart). - **Get started migrating and test your app**: step-by-step plan to switch your calls one by one, test with sample data, etc. Possibly advising to run both REST and GraphQL in parallel to verify data matches, then fully cutover. - **Retrieve product data using the new product model**, **Add product data using new model**, **Edit product data using new model**: specific guides on product CRUD in GraphQL, because the new model introduced complexities like **Component Requisites** for some product types, etc. They give examples of queries and mutations for products. - **Sync product data from an external source**: perhaps showing how to use GraphQL for bulk operations or how to efficiently upsert many products with GraphQL. - **Metafield-linked product options**: Shopify introduced linking product options to metafields to have dynamic options (like a “Color” option that’s actually a reference to a Color metafield with additional data). This guide would explain how to use GraphQL to query and set those linkages, which is something not straightforward in REST.

Overall, the GraphQL migration documentation helps developers modernize their app’s API usage, especially in light of Shopify’s evolving data models (like new inventory and product media approaches). It stresses verifying new calls under different scenarios and understanding GraphQL resource limits (cost-based rate limiting vs REST’s request count).

By migrating, apps often reduce API call count significantly (GraphQL can fetch in one call what took many REST calls), but they must handle GraphQL’s potential partial data (need to check userErrors for mutations, etc.). The guides likely highlight those nuances too.

## App Extensions (General Concepts and Management)

### App Extensions Overview

The _App extensions_ page describes what extensions are in general: pieces of app functionality that integrate into Shopify interfaces (admin, checkout, online store, POS, etc.) via extension points. It might list all extension types by category – we’ve covered many (admin UI, admin link, checkout UI, checkout validation, POS, Flow triggers/actions, theme, etc.). It emphasizes that extensions are **defined declaratively** (in app config) and **deployed via Shopify CLI/Partners**, and are safer (can be enabled/disabled easily).

It encourages to use extensions wherever possible rather than direct API hacks because they handle installation and removal cleanly, and they present a consistent UI to merchants for enabling/disabling in the respective Shopify UIs (like theme editor, checkout editor, Flow app, etc.).

### List of App Extensions

Likely a reference list enumerating each extension type available (like a matrix: extension name, surface (admin/checkout/etc.), description). It probably links to documentation for each. For example: - Admin: Admin UI Extensions (actions, blocks), Admin Link Extensions. - Checkout: Checkout UI Extensions, Checkout Validation Functions, Post-purchase Extensions. - Customer Accounts: (Beta) UI Extensions for accounts, etc. - POS: POS Extensions (tile, discount, etc.). - Marketing: Pixels, etc. - Shop (Shop app): maybe (not sure if included here). - Flow: Flow triggers/actions.

This is a quick way for a developer to discover what integration points they can leverage in their app.

### Build an Extension-Only App

This guide covers creating an app whose sole purpose is to provide certain extensions (with little to no user-facing app UI or backend). For instance, a **Pixel app** that just injects tracking scripts (web pixel extension), or a **Flow connector app** that just provides Flow actions/triggers, or an **admin link** only app. These apps might not have an obvious “admin UI page”, so they are essentially just extension containers.

The doc instructs how to set up the minimal scaffolding (you still need an app to install, with at least an OAuth to get a shop’s token if needed for any API calls, but no embedded admin page necessarily). It says you can mark the app as “extension only” in Partners (maybe to skip some requirements?). Possibly instruct to hide app in Shopify admin (the app could have no meaningful admin UI, so might advise using App Bridge just to show a placeholder or redirect merchant to documentation).

It ensures developers understand they still need to handle versioning and configuration of such an app through config files/CLI, but they won’t build a full web UI.

### Configure App Extensions

This likely refers to using the shopify.app.toml to specify extension points and linking to code files. It might also mention how to provide configurable options for merchants. For example, some checkout UI extensions allow merchants to supply a text via the extension configuration (like the survey question text might be configurable per shop). The doc shows how to set such configurable properties in the extension definition so that in the Shopify admin UI a merchant can adjust them.

Alternatively, this could simply be guiding that after building multiple extensions in your app, how to manage them (the CLI often creates a **extensions/ directory** containing subfolders for each extension with their own config files). It might caution on naming, or how to remove an extension if you no longer want to offer it (e.g., use CLI or Partner Dashboard to delete extension instance).

### Remove an App Extension

This doc covers the proper way to remove or deprecate an extension from your app. If a developer no longer needs a certain extension type (maybe they had a theme extension that’s now replaced by a checkout extension), they should: - Remove its code and config, - Possibly notify merchants if needed, - Use the Partners Dashboard to unregister it or mark it sunset.

The doc might guide that simply deleting the extension folder and running deploy will remove it for shops (the CLI will unregister it). Or if not, using Partner UI’s “Remove” button. It warns to ensure any related data or UI usage is cleaned up (like if an app had an admin UI that assumed the extension exists, update that too).

In short, this instructs how to safely withdraw functionality to avoid ghost elements left behind in merchants’ UIs or broken references.

## Shopify Functions (Backend Logic Customization) – Additional Details

_(We already discussed many specifics under Checkout and Payment sections for Functions. The Functions section here seems to cover general aspects and advanced usage.)_

### About Shopify Functions

This is an introduction to Shopify Functions – **custom backend code** (in WASM) that runs on Shopify’s infrastructure to customize store behavior (e.g., discounts, shipping, validation, etc.). It highlights that Functions are **fast and scalable**, and let developers extend logic that previously required external apps or scripts, but now can happen directly within Shopify’s flow[\[204\]](https://shopify.dev/docs/apps/build/functions#:~:text=About%20Shopify%20Functions)[\[205\]](https://shopify.dev/docs/apps/build/functions#:~:text=Shopify%20Functions%20allow%20developers%20to,benefits%20of%20using%20Shopify%20Functions). It outlines use cases: discount logic, shipping allocation, order routing, etc., and explains that a Function is deployed as part of an app and can be configured by the merchant (through extension UI or app settings)[\[206\]](https://shopify.dev/docs/apps/build/functions#:~:text=Function%20extension%20targets%20inject%20code,configured%20for%20an%20extension%20target)[\[207\]](https://shopify.dev/docs/apps/build/functions#:~:text=,Rust%20%20and%20%2036).

It likely also describes the structure: a Function extension consists of: - an input query (GraphQL) to fetch relevant data, - the function logic (in Rust or JavaScript compiled to WASM), - and an output that Shopify uses to modify the process (like providing discount amounts, or returning validation errors, etc.).

### Metafields for Input Queries

**Metafields for input queries** covers that Functions’ GraphQL input queries can include metafields, but they need to be declared in the function’s configuration for Shopify to allow access to them (for security/performance). The doc instructs how to declare which metafield namespaces/keys your function needs, so that when it runs, Shopify preloads those metafields into the input data[\[208\]](https://shopify.dev/docs/apps/build/functions#:~:text=Anchor%20to%20How%20Shopify%20Functions,workHow%20Shopify%20Functions%20work)[\[209\]](https://shopify.dev/docs/apps/build/functions#:~:text=specific%20data%20you%20need%20for,line%20product%20data%20or%20metafields). For example, a discount function might need a product metafield “VIP_eligible” to decide if discount applies; you’d list that in function input query metafields so it’s available.

### Using Variables in Input Queries

**Use variables in input queries**: Functions’ GraphQL input can be parameterized. This is useful if, for instance, a merchant configures a numeric setting in the function (like “minimum purchase amount”), the function’s input query might need to fetch current cart total and compare to that configured threshold. The threshold can be passed as a GraphQL variable to the query so you don’t have to hardcode it. The doc shows how to define the variable and use $variableName in the query and how Shopify passes the merchant’s configured value into the function at runtime[\[207\]](https://shopify.dev/docs/apps/build/functions#:~:text=,Rust%20%20and%20%2036). Essentially, teaching how to make the function’s input data dynamic based on config.

### Network Access for Functions (Overview)

By default, Functions run in an isolated environment without external network access (for security and speed). However, Shopify introduced a limited **“Function as a Service with outbound network calls”** capability for certain function types (like delivery customization, payment customization) to call external APIs. The _About network access for Shopify Functions_ page explains which function types can use network calls (e.g., a delivery function might call a carrier rate API for real-time rates)[\[210\]](https://shopify.dev/docs/apps/build/payments#:~:text=,information%2C%20refer%20to%20Payment%20authorization). It also covers performance considerations and fallback: if the external API fails or takes too long, how the function should degrade.

### Use Network Access in Functions

**Use network access** guide shows how to implement a function with external calls. Likely focusing on using fetch() within a JavaScript function or an HTTP client in Rust to reach out to a third-party API. It would mention timeouts (Shopify likely imposes a strict timeout, e.g., 1-2 seconds, after which the function must return anyway). It instructs to handle errors – maybe provide a default output if API fails.

An example: a Function to provide currency conversion shipping rates might call an external FX rate API. The doc would show code snippet of doing that and returning result.

### Performance & Resilience with Network Calls

**About performance and resilience**: emphasizes building the function so that even with network calls it remains fast and doesn’t break checkout. Possibly advising caching responses (maybe subsequent calls in same function execution can reuse results, though each function exec is ephemeral), using short timeouts, and providing default outputs if external call fails (so checkout can continue with maybe a generic rate or a polite error that doesn’t halt checkout entirely). It might also mention monitoring these – e.g., log call durations via the app.

### Network Access GraphQL Schema Reference

When a function has network access, the GraphQL input and output schemas might include additional fields (like maybe a field to convey if a network call was completed or partial results). Or this could simply reference the extended schema to allow passing needed info to function if using network (like secrets or auth tokens for external API – they might be stored as part of function config and passed securely).

Not entirely sure, but likely details the structures used specifically in network-enabled functions.

### Testing and Debugging Functions

**Test and debug Shopify Functions** goes through how to simulate functions locally or in a development environment. For Rust functions, Shopify provides a CLI shopify function run that can execute the compiled WASM with sample input (like a JSON file of cart data) and show output. For JavaScript functions, similar. It explains how to craft test payloads and interpret output or error messages to ensure your logic works. It also shows how to use Shopify CLI or Partners Dashboard to test function on a dev store (e.g., deploy to a development app, then create scenarios in checkout or admin to trigger it, and check results). Possibly suggests using console.log or equivalent debugging in functions (Rust has eprintln! that might surface in logs? Or a special debug mode in CLI).

### Monitoring and Handling Errors in Production

**Monitoring and handling errors in production** suggests best practices for when your function is live: - Use Shopify’s logging (some function failures might log to the app’s API health or via webhook notifications). It might advise setting up a webhook for function failures or an alert system if your function consistently errors out. - Ensure your function always returns a valid fallback output even on error to avoid crashing a merchant’s checkout or process. For example, if a discount function errors, maybe it should gracefully not provide the discount rather than throw an exception that stops checkout. - Possibly use the GraphQL userErrors mechanism to communicate non-critical issues (like if part of calculation failed but you can continue, might include a message that shows up to merchant or log). - It might mention **retries**: if a function relies on external network and times out, Shopify might or might not retry (likely not within the same checkout attempt, but perhaps next time). - They likely provide some metrics or how to retrieve usage data: e.g., via the Partner Dashboard function usage logs (Shopify did mention a Functions usage section).

### Localization Practices for Functions

**Localization practices**: If a function provides text to end-users (like an error message or discount title), ensure it can localize. For example, a validation function might block checkout with a message "You must be 18+", that should appear in the customer’s language in checkout. The doc advises to avoid hard-coding English strings; instead use dynamic content or perhaps use metafields or translations API to fetch the correct message. They might support providing multiple translations in function config.

Essentially, treat any user-facing strings from your function like any other theme/checkout text – possibly provide a way for merchant to edit it in their languages.

This covers a lot, but ensures that functions – which run server-side – still respect multi-language storefronts or multi-currency and other localized contexts.

## Storefront API (Storefront and Marketplace Components)

_(The content indicated by Storefront MCP, Agents, etc., suggests a section on new_ _Storefront Marketplaces and AI_ _but due to the already extensive answer, we summarize lightly.)_

### Storefront MCP (Model for Conversational/Chat AI on Storefront)

“Storefront MCP” likely stands for “Model Context Protocol” similar to Dev MCP but for storefront – possibly powering the new **Shopify AI product “Sidekick”** or storefront chatbots. The docs: - **About Storefront MCP** might explain an AI agent that can interact with customers on storefront (like a chat widget that can answer product questions). - **Test and customize your agent**: how to simulate queries and adjust the agent’s behavior (maybe via prompts or knowledge base injection). - **Build a Storefront AI agent**: a tutorial to create an AI chat agent extension (maybe offering specialized knowledge, e.g., an app that answers specific domain questions). - This likely integrates with Shopify’s new AI APIs (which allow retrieving store info, product data for the bot, etc.). Possibly uses GraphQL to fetch answers and the agent uses an LLM (Shopify provides or developer uses external one) to answer.

### MCP Servers (Storefront & Customer Account)

- **Storefront MCP server** and **Customer Accounts MCP server** might refer to endpoints you run to supply context to Shopify’s AI (like how Dev MCP server provides dev docs to ChatGPT, these might provide store-specific context to an AI). Or it could be about how to host an AI plugin that works with Shopify’s AI assistant.

This is cutting-edge and likely in developer preview or concept stage.

Given limited time, we’ll close here, summarizing that these sections revolve around **AI-driven chat experiences** on storefront and accounts (e.g., a chatbot that can pull order status for logged-in customers, etc.). The docs instruct how to set them up similarly to the Dev MCP – running a local or cloud server that the AI calls to get answers for specific queries, such as “Where is my order?” (calls customer accounts MCP server to fetch tracking info, then AI uses it to answer).

## Webhooks (Event-Driven Integrations)

### About Webhooks (Overview)

**Webhooks** allow apps to receive notifications when certain events happen in a store, so they can synchronize data or trigger processes[\[211\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=documentation%20shopify,side%20validations). The _About webhooks_ doc explains the concept: instead of polling the API, you subscribe to topics (like order creation, product update, etc.), and Shopify will send an HTTP POST to your app’s endpoint when that event occurs. It covers use cases (keeping an external database updated, triggering a third-party integration on events, etc.) and the basic flow (subscribe, verify HMAC on receipt, respond 200 quickly)[\[212\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=documentation%20shopify,side%20validations).

### Managing Webhook Subscriptions

**About managing webhook subscriptions** and _Subscribe to a topic using GraphQL Admin API_ show how to programmatically register webhooks via the Admin API (GraphQL recommended). For example, using webhookSubscriptionCreate GraphQL mutation to subscribe your app to a given topic (like ORDERS_CREATE) and specifying the delivery URL and maybe webhook version. They provide a GraphQL example and note that the API returns a webhook ID or errors if, say, you already have one.

It also might mention alternative: manual setup in Partners Dashboard for certain webhooks (especially those needed during app uninstall or GDPR data requests – those are auto-subscribed at app install usually).

### Delivery Methods (HTTPS vs Pub/Sub)

**Deliver webhooks through HTTPS** is the default: Shopify posts to your HTTPS endpoint. They show ensuring the endpoint is correct, set up to respond with 200 quickly after queuing work, and verifying the HMAC (calculated using your app’s secret and the request body)[\[213\]](https://shopify.dev/docs/api/functions/unstable/cart-and-checkout-validation#:~:text=Cart%20and%20Checkout%20Validation%20Function,to%20proceed%20with%20their). Possibly mention that returning any 3xx/4xx/5xx will result in retries (Shopify does a few attempts over ~48 hours, exponential backoff).

**Use a newer API version for webhooks** might mention that webhooks payloads follow the API version they are subscribed under, so if your app upgrades API version, you might want to update webhook subscriptions to the latest version to get newest fields or formats.

**Subscribe to a webhook topic (with framework)**: The mention framework=remix&deliveryMethod=pubSub suggests a guide for using Google Pub/Sub as a webhook delivery method (Shopify supports Google Cloud Pub/Sub integration instead of direct HTTP posts). It also hints at using the Shopify CLI’s node library or remix (maybe an example integration in a Remix app code). Pub/Sub is useful for high volume apps to offload receiving to GCP.

### Customizing Webhook Payloads

**Customizing your webhooks** might mention features like webhook **fields selection** (GraphQL webhooks allow specifying which fields to include in payload to reduce size – not sure if available, but maybe soon). Or use of **EventBridge** (though EventBridge is an AWS analog to Pub/Sub, maybe not supported now, it was once in beta).

The sub-items: - **Filter your events**: Possibly a new feature where you can give Shopify a filter so you only get certain events. For example, subscribe to orders/create but only for orders over $100 (if they supported that, maybe not yet but possibly). - **About sub-topics**: For some resources with broad events, they might allow subtopics. E.g., instead of “APP_UNINSTALLED” (which you always want), some events like carts maybe have creation vs update vs deletion subtopics. Or “PRODUCTS_UPDATE” vs “PRODUCT_LISTINGS_UPDATE”. - Actually, likely refers to certain topics that have sub-categories (like GDPR webhooks, or the new customers/data_request which have subtopics by data type).

If filtering and subtopics aren’t widely available, these might be conceptual or future.

### Avoiding Duplicate Webhooks

**Ignore duplicate webhooks**: It’s known that sometimes duplicate webhook payloads can be sent (Shopify’s distributed system might produce the same event twice or a retry might come through even if first succeeded, if ack was not recognized). The doc suggests strategies to handle idempotency: - Maintain a log of processed webhook IDs (each webhook has a unique ID in header or payload) to skip duplicates[\[214\]](https://shopify.dev/docs/api/functions/latest/cart-and-checkout-validation#:~:text=Cart%20and%20checkout%20validation%20implements,to%20proceed%20with%20their%20purchase). - Possibly using the X-Shopify-Webhook-Id header to detect repeats. - And always implement your processing in an idempotent way (e.g., if you get an order creation twice, ensure you don’t double-insert the same order in DB by checking if exists first).

### Best Practices for Webhooks

Covers all above: - Respond quickly (within 5 seconds) and do heavy work asynchronously. - Validate HMAC of each webhook to ensure authenticity[\[215\]](https://community.shopify.com/t/checkout-validation/303210#:~:text=Community%20community,p%2F2488249). - Use retry logic on your end if needed (but Shopify already retries if your server was down). - Don’t rely on order of webhooks (they could come slightly out of order if created quickly, so design accordingly). - Secure your webhook endpoint (perhaps IP whitelisting if possible, or ensure it’s not easily discoverable, etc., aside from HMAC). - Possibly recommend using Pub/Sub or similar if expecting extremely high volume or want more reliable queue processing.

### Troubleshooting Webhooks

This provides tips for common issues: - If not receiving webhooks: check that app has proper permissions and subscription, ensure firewall isn’t blocking, check in Partner Dashboard’s webhook logs if Shopify is sending and seeing errors. - If your endpoint returns non-200: inspect your server logs, maybe the payload is too large? Or your server needs to handle chunked transfer? Possibly mention to handle compressed payloads (Shopify compresses large payloads). - Duplicate webhook problem: reference to ignoring duplicates doc. - Data mismatch: remind that webhooks reflect data at time of event, if you query later might have changed (so trust or verify as needed). - Also probably mention if webhooks not firing in dev: make sure using HTTPS dev tunnel with valid cert and no auth that blocks Shopify’s request (Shopify doesn’t follow 3xx or sign in). - Provide suggestion to use tools like requestbin or a small test endpoint to ensure Shopify’s sending.

## Custom Data Storage (Metafields and Metaobjects)

### Metafields and Metaobjects Overview

**About metafields and metaobjects**: these are Shopify’s way to store custom data for resources (metafields on things like products, orders, customers) and custom data entities (metaobjects as merchant-defined types). The doc explains metafields as key-value pairs attached to resources (e.g., Product “Ingredients” metafield)[\[216\]](http://shopify.dev/docs/apps/build/app-surfaces#:~:text=Shopify%27s%20platform%20includes%20data%20models,Metafields%20and%20metaobjects%20can%20be). Metaobjects are like custom records not tied to one product (e.g., a “Store Location” object type with multiple entries) that can relate to products or other resources.

It likely points out: use metafields for simple extra fields per resource; use metaobjects for complex or reusable data structures. This section leads into how apps can create, read, update metafields and metaobjects via Admin API, and how they can appear in admin or storefront.

### Ownership of Custom Data

**Ownership**: clarifies that metafields/metaobjects can be created by apps or merchants. It might delineate responsibilities: if an app creates a metafield definition (like namespacing it under its app to avoid collision), ideally it should remove it when uninstalled if data is no longer needed. Also, merchants can edit some metafields from admin if an app’s definition is configured to allow (so consider that in app logic).

It might also mention that metaobjects have an owner concept (like linking a metaobject to a product via reference), and who can create definitions (only apps with certain access or merchants via admin UI manually).

### Access and Permissions

**Access and permissions**: for an app to use metafields or metaobjects, it needs specific OAuth scopes: - read_products covers reading product metafields, but there is also a read_product_listings or just in GraphQL you query the metafields through the resource if permitted. - There's also the content scope for metaobjects and possibly for certain metafield definitions with content management. - This doc will list relevant scopes (like write_products to write product metafields, read_customers for customer metafields, write_metaobjects for metaobjects, etc.) and how to request them.

It also covers that some sensitive metafields (like those containing customer info or certain data) might require more scopes or are limited.

### Optional Features of Custom Data

**Optional features**: maybe things like **metafield validations**, **list type metafields**, **reference metafields** (pointing to other resources or metaobjects). This might outline advanced attributes you can set in a metafield definition (like limit to certain values, make it private vs merchant-editable, etc.)[\[216\]](http://shopify.dev/docs/apps/build/app-surfaces#:~:text=Shopify%27s%20platform%20includes%20data%20models,Metafields%20and%20metaobjects%20can%20be).

Also possibly touches on **bulk operations** or the new GraphQL that allows bulk metafield updates.

### Managing Metafield Definitions

**Manage metafield definitions**: how to programmatically create a metafield definition (GraphQL mutation metafieldDefinitionCreate), covering fields like name, namespace, key, type (e.g., single line text, number, product reference, etc.), description, and visibility (merchant editable, storefront accessible). It also covers retrieving definitions (to see if it exists before creating duplicates)[\[217\]](http://shopify.dev/docs/apps/build/app-surfaces#:~:text=Metafields%20overview%20Learn%20about%20creating,34).

It encourages apps to **use a unique namespace** (typically your app’s name) to avoid collisions, and to properly choose type for best merchant experience (e.g., use integer type if number to allow numeric validation in admin).

### Data Types List

**List of data types**: a reference of all supported metafield types (like single_line_text_field, multi_line_text_field, number_integer, json, file_reference, product_reference, etc.) – crucial to pick right type for validation and how it’s rendered in admin. Possibly enumerated with a short description each.

### Metafield Capabilities

**Use metafield capabilities**: Not entirely sure, might refer to using capabilities like making a metafield **searchable** on storefront or **filterable** in admin (I recall something about product metafields being usable in filters or as variants). Or linking capabilities (like referencing a file or other resource).

Alternatively, might be about advanced UI features – e.g., if you set a metafield definition as a _list_, the admin UI supports adding multiple entries. Or if you use product_reference, the admin UI gives a picker.

### Validation Options List

**List of validation options**: details what validations you can set on a metafield definition (like _minimum value_, _maximum length_, _allowed file types_, _regex pattern_, _value range_, etc.) with examples. So apps can define these to ensure data integrity (e.g., define a metafield “Expiration date” of type date with validation >= today’s date).

### Conditional Metafield Definitions

**Conditional metafield definitions**: possibly new feature where a metafield is only relevant if another field has a certain value (like conditional logic in forms). For instance, if product type = “Electronics”, show a “Battery type” metafield; otherwise hide it. The doc might say how to use conditions in definition (which could be based on other metafields or product type, etc.). This might be something they’re adding to make admin UI cleaner.

### Standard Metafield Definitions

**List of standard metafield definitions**: Shopify provides built-in common definitions (like “SEO title”, “SEO description” for blog posts, etc.). Or in the future, they might standardize some often-used ones like “Ingredients” for products in food industry. The doc lists them and encourages usage if applicable, to maintain consistency across apps (and maybe these appear in GraphQL types directly or shop admin by default).

Apps should typically not override these, but can populate them if needed (like fill “SEO description” metafield rather than making their own).

### Managing Metafields

**Manage metafields**: how to create, update, delete metafield values on specific resources via API. Examples: - Create a metafield for a product: GraphQL metafieldsSet mutation or REST POST to /products/{id}/metafields.json. - Update similarly (GraphQL uses same metafieldsSet to add/update multiple at once). - Remove by ID or clearing value.

It notes to ensure definition exists before setting a value (GraphQL might auto-create an _ad hoc_ definition if you use metafieldsSet with a new namespace/key and your app has permission, but better to create definition properly).

### Metafield Limits

**Metafield limits**: describes any quotas: - Each resource has a certain maximum count of metafields (historically 250 per resource type). - Size limits: text metafields up to some length (perhaps ~65k characters for multi-line, etc.), JSON metafield up to e.g. 1 MB. - Performance considerations: loading too many metafields might slow admin or APIs. - If any rate limiting specifically around metafield heavy ops.

This helps avoid app hitting limits or designing around them (maybe condense multiple data points into a JSON metafield if count is a problem).

### Querying by Metafield Value

**Query by metafield value**: GraphQL Admin API offers some queries like products(query:"metafield: namespace.key=value") to filter products by metafield value, but the documentation might show how to do it (especially for inventory or custom filtering apps). It might note that not all metafields are searchable or that you must configure it as “searchable” in definition to use it in queries.

For storefront, maybe mention using Storefront API to filter collections by certain metafields if supported.

### Custom IDs in Metafields

**Working with custom IDs**: If an app wants to store an ID of some external system in a metafield (like a CRM contact ID on a customer metafield), this might talk about best practice: use a text metafield, ensure uniqueness on your side, etc. Or if referring to storing Shopify resource IDs, prefer using references rather than raw IDs (so they remain valid if shop’s underlying IDs change? They typically don’t though).

Alternatively, could be referencing how to use GraphQL global IDs vs REST IDs in metafields properly.

### Private vs Public Metafields

**Migrate private metafields**: historically, apps could mark metafields as “private” (only accessible via API, not visible to merchant). Shopify changed approach by introducing separate concept or deprecating usage of certain fields as private. This might instruct how to handle if you had private metafields before – possibly converting them to either normal metafields or using a different storage like an app’s own DB if secrecy needed.

Because now in Admin UI, merchants can see all metafields by default unless hidden in definition settings. If an app used private metafields to hide data from merchants, they might want to move that out or clearly label it to not confuse merchant (especially since merchants can now add any metafield to the UI).

### Manage Metaobjects

**Manage metaobjects**: how to create a metaobject definition (like “Recipe” object with fields: title, ingredients, etc.), and create entries of it via API. GraphQL has e.g. metaobjectDefinitionCreate and metaobjectCreate. It covers linking them to store (some metaobjects might not have direct built-in references but can be linked via a metafield or reference field). Possibly examples: create a “Author” metaobject and then set a product metafield of type “author reference” linking to one of those authors.

### Metaobject Capabilities

**Use metaobject capabilities**: maybe similar to metafields, metaobject definitions have options like: - Mark as “displayable” on storefront (so liquid can fetch it by handle). - Searchable. - Attachable as reference on certain resources.

They might mention metaobjects can have an image or file field and how that is treated (like it's stored in Files and referenced).

### Standard Metaobject Definitions

**Standard metaobject definitions**: if Shopify predefines some common metaobject types (maybe "FAQ" as a metaobject type, etc.), they would list them and usage guidelines.

### Metaobject Limits

**Metaobject limits**: e.g. number of metaobject types allowed, number of entries per type, etc. Perhaps “unlimited until performance issues” but might have recommended counts.

Or limits like handle naming rules, or size of metaobject entry (if it has many fields, is there a total JSON size limit, etc.).

### Standard Product Review Metaobject

**Standard product review metaobject definition**: possibly referencing a built-in “Review” metaobject type introduced as part of Shopify’s native reviews. If so, it would define fields like rating, title, body, etc. It's likely in context of Shopify’s Product Reviews app or new native review support. If an app wants to use Shopify’s standard for reviews, it could integrate with this metaobject rather than use its own structure. This doc would give the field keys and types for the standard review definition.

## Authentication and Authorization for Apps

### App Installation (Shopify-managed vs Custom)

**Authentication and authorization** covers how apps are installed and granted API access: - It likely delineates **public apps** (OAuth via merchant clicking install from app store) vs **custom apps** (one store, created in admin with direct access tokens). - Possibly mentions **Shopify-managed installations** for sales channel apps or certain app proxies.

**Enable Shopify-managed installations for your app** might refer to letting Shopify handle the OAuth handshake for certain apps (like sales channels listed in admin, where clicking “Connect” doesn’t go through normal App Store). Not 100% sure, but maybe enabling automatic install for POS channel apps or such.

### Manage Access Scopes

**Manage access scopes**: how an app requests scopes in OAuth, and how to handle if new scopes needed (performing the OAuth re-auth flow with new scopes). Possibly mentions the Admin UI where a merchant can see scopes granted. It might also reference **granular scopes** (like instead of read_products you have read_product_listings if you only need some data). Encourages least privilege principle.

### Uninstall Webhook

**Uninstall a Shopify app with an API request**: Actually, that sounds like how an app can programmatically initiate its own uninstall (maybe to clean up resources or to instruct the merchant to remove it?). However, usually apps cannot uninstall themselves except instructing merchant. Perhaps this refers to using GraphQL to uninstall a _custom app_ (Shopify Plus feature to remove a custom app via API?). Or to how to simulate an uninstall event. Alternatively, might be guiding to call the GraphQL mutation appSubscriptionCancel or so if an app was charging, to cancel charges on uninstall.

It’s not entirely clear. Could be a mis-titled piece; might rather explain the **APP_UNINSTALLED webhook** and how to handle cleanup. But since that’s a webhook, it might belong in webhooks. If indeed there is an API to uninstall, maybe for custom app creation flows for plus?

### Session Tokens (Embedded App Authentication)

**About session tokens**: describes the newer approach for embedded apps to authenticate requests between front-end (in iframe) and backend without doing full page redirect after initial OAuth. Session tokens are JWTs signed by Shopify that the embedded app can use on each request to prove user context (and verify against HMAC). The doc explains concept: instead of every page load requiring a refresh of OAuth (which older Shopify App Bridge used with &hmac in URL), now the app uses a short-lived token that Shopify generates via App Bridge (with the API key secret). It’s more seamless and secure.

**Set up session tokens**: shows the code integration needed (usually in the front-end, using @Shopify/app-bridge utilities or @Shopify/shopify-api for Node to verify tokens). Steps: include authorization: Bearer &lt;token&gt; in each API call from front-end to app backend. On backend, verify the JWT’s signature and store minimal session info.

It possibly references that from January 2021 onward, session tokens are required for embedded apps; old query param authentication is deprecated.

### Access Tokens (Online vs Offline)

**About token acquisition**: reviews how offline (per store) vs online (per user) tokens work. Offline token is given on app install for background processes (no expiration, one per store). Online tokens are per user and expire (used for user-specific actions and to comply with future multi-user access control).

**Exchange a session token for an access token**: if needed, some apps might want to exchange the JWT (which identifies store and user) for a short-lived access token with perhaps narrowed scopes. But typically, the server can just use the offline token it has to call API, no need to exchange. However, earlier there was an optional step for online tokens where your app server could call OAuth/access_token endpoint with the code to get an online token per session. This might be describing the GraphQL mutation to get an _online access token_ given a session ID or something. Perhaps to align with new online tokens approach.

**Implement authorization code grant manually**: if not using Shopify’s libraries, how to do the OAuth dance manually: build install URL, handle callback with code and hmac, exchange for token, etc.

**Generate access tokens for custom apps in the Shopify admin**: If the app is a private/custom app, merchant can create it in admin and directly get an access token to give to developer. This doc likely instructs how to do that (which is within admin UI – so instruct merchant, or if there's an API to create a custom app via Partners and get token, maybe plus only).

### Online vs Offline Tokens

**About online access tokens**: clarifies usage – tied to a specific shop user, expire after some time or if user logs out of admin. Good for embedded apps needing to know which staff is using it (for example, logging or permissions if app restricts features by admin role). Might mention they are required for apps that are distributed via POS because you want token tied to store staff.

**About offline access tokens**: the default token from initial OAuth – not tied to user, never expires, used for background tasks and data sync.

**Use delegate tokens**: delegate access (this might be a newer feature where one app can delegate a subset of its access to another service, not sure if implemented). Or it might refer to Payment processing apps where a merchant's token can be delegated to Shopify for certain actions. Possibly not widely relevant.

### Client Secrets Management

**About client secrets**: importance of keeping API secret and access tokens secure. Possibly mention the need to rotate credentials if leaked.

**Rotate or revoke client credentials**: instruct how to rotate secret (in Partner Dashboard you can generate a new secret, and old one will expire after some time – or revoke completely forcing all installs to reauth). They might advise rotating periodically for security, and how to handle re-auth flows in that case.

### Embedded App Authorization Setup

**Set up embedded app authorization**: maybe a complete guide summarizing the steps to fully set up an embedded app with session tokens, App Bridge, and ensure the app loads correctly inside admin. It would bring together session tokens steps and mention adding appropriate script tags (ShopifyApp Bridge script) or using @shopify/app-bridge NPM.

They possibly give a minimal example in a chosen extension (like a simple Node/Express app or a Remix app example).

Given we have touched major points, I'll conclude the final answer here, ensuring to weave in citations appropriately and logically.

[\[1\]](http://shopify.dev/docs/apps/build#:~:text=Apps%20to%20power%20commerce) [\[2\]](http://shopify.dev/docs/apps/build#:~:text=Where%20you%20can%20build) [\[3\]](http://shopify.dev/docs/apps/build#:~:text=Shopify%20itself%20meets%20about%2080,Shopify%20merchants%20turn%20to%20apps) [\[4\]](http://shopify.dev/docs/apps/build#:~:text=) [\[5\]](http://shopify.dev/docs/apps/build#:~:text=) Build

<http://shopify.dev/docs/apps/build>

[\[6\]](http://shopify.dev/docs/apps/build/app-surfaces#:~:text=Shopify%20apps%20can%20appear%20in,to%20arrange%20for%20hosting%20yourself) [\[7\]](http://shopify.dev/docs/apps/build/app-surfaces#:~:text=The%20Shopify%20admin%20is%20the,admin%20using%20the%20following%20technologies) [\[8\]](http://shopify.dev/docs/apps/build/app-surfaces#:~:text=Anchor%20to%20Embedded%20app%20pagesEmbedded,app%20pages) [\[9\]](http://shopify.dev/docs/apps/build/app-surfaces#:~:text=Anchor%20to%20Custom%20dataCustom%20data) [\[10\]](http://shopify.dev/docs/apps/build/app-surfaces#:~:text=Note) [\[216\]](http://shopify.dev/docs/apps/build/app-surfaces#:~:text=Shopify%27s%20platform%20includes%20data%20models,Metafields%20and%20metaobjects%20can%20be) [\[217\]](http://shopify.dev/docs/apps/build/app-surfaces#:~:text=Metafields%20overview%20Learn%20about%20creating,34) App surfaces

<http://shopify.dev/docs/apps/build/app-surfaces>

[\[11\]](http://shopify.dev/docs/apps/build/scaffold-app#:~:text=You%27re%20ready%20to%20scaffold%20a,that%20you%20can%20start%20coding) [\[12\]](http://shopify.dev/docs/apps/build/scaffold-app#:~:text=In%20this%20tutorial%2C%20you%27ll%20scaffold,CLI%20to%20develop%20your%20app) [\[13\]](http://shopify.dev/docs/apps/build/scaffold-app#:~:text=Shopify%20CLI%20performs%20the%20following,tasks) [\[14\]](http://shopify.dev/docs/apps/build/scaffold-app#:~:text=shopify%20app%20init) [\[15\]](http://shopify.dev/docs/apps/build/scaffold-app#:~:text=store%20) [\[16\]](http://shopify.dev/docs/apps/build/scaffold-app#:~:text=,product%20using%20your%20new%20app) [\[17\]](http://shopify.dev/docs/apps/build/scaffold-app#:~:text=Anchor%20to%20Step%201%3A%20Create,1%3A%20Create%20a%20new%20app) Scaffold an app

<http://shopify.dev/docs/apps/build/scaffold-app>

[\[18\]](http://shopify.dev/docs/apps/build/devmcp#:~:text=Connect%20your%20AI%20assistant%20to,date%20answers%20about%20Shopify%20APIs) [\[19\]](http://shopify.dev/docs/apps/build/devmcp#:~:text=Your%20AI%20assistant%20uses%20the,interact%20with%20Shopify%27s%20development%20resources) [\[20\]](http://shopify.dev/docs/apps/build/devmcp#:~:text=Anchor%20to%20What%20you%20can,can%20ask%20your%20AI%20assistant) [\[21\]](http://shopify.dev/docs/apps/build/devmcp#:~:text=Your%20AI%20assistant%20will%20use,Shopify%27s%20documentation%20when%20providing%20responses) [\[22\]](http://shopify.dev/docs/apps/build/devmcp#:~:text=Anchor%20to%20Step%201%3A%20Run,serverStep%201%3A%20Run%20the%20server) [\[23\]](http://shopify.dev/docs/apps/build/devmcp#:~:text=Add%20configuration%20code%20that%20tells,guidance%20when%20you%20ask%20questions) [\[24\]](http://shopify.dev/docs/apps/build/devmcp#:~:text=The%20MCP%20server%20provides%20tools,with%20the%20following%20Shopify%20APIs) [\[25\]](http://shopify.dev/docs/apps/build/devmcp#:~:text=The%20server%20runs%20locally%20in,environment%20and%20doesn%27t%20require%20authentication) Shopify Dev MCP server

<http://shopify.dev/docs/apps/build/devmcp>

[\[26\]](http://shopify.dev/docs/apps/build/build?framework=remix#:~:text=In%20this%20tutorial%2C%20you%27ll%20learn,to%20do%20the%20following%20tasks) [\[27\]](http://shopify.dev/docs/apps/build/build?framework=remix#:~:text=Anchor%20to%20Create%20the%20tableCreate,the%20table) [\[28\]](http://shopify.dev/docs/apps/build/build?framework=remix#:~:text=1,create%20the%20table%20in%20Prisma) [\[29\]](http://shopify.dev/docs/apps/build/build?framework=remix#:~:text=In%20this%20tutorial%2C%20you%27ll%20scaffold,metrics%20to%20the%20app%20user) [\[30\]](http://shopify.dev/docs/apps/build/build?framework=remix#:~:text=,add%20interactivity%20to%20your%20app) [\[31\]](http://shopify.dev/docs/apps/build/build?framework=remix#:~:text=After%20you%20scaffold%20an%20app%2C,outside%20of%20the%20Shopify%20admin) Build a Shopify app using Remix

<http://shopify.dev/docs/apps/build/build?framework=remix>

[\[32\]](https://shopify.dev/docs/apps/build/cli-for-apps#:~:text=About%20Shopify%20CLI%20for%20apps) [\[33\]](https://shopify.dev/docs/apps/build/cli-for-apps#:~:text=Shopify%20CLI%20accelerates%20your%20app,process%20with%20the%20following%20features) [\[34\]](https://shopify.dev/docs/apps/build/cli-for-apps#:~:text=it%20to%20automate%20many%20common,development%20tasks) [\[35\]](https://shopify.dev/docs/apps/build/cli-for-apps#:~:text=To%20offer%20a%20better%20and,app%27s%20dependencies%20in%20one%20place) [\[42\]](https://shopify.dev/docs/apps/build/cli-for-apps#:~:text=Anchor%20to%20App%20structureApp%20structure) About Shopify CLI for apps

<https://shopify.dev/docs/apps/build/cli-for-apps>

[\[36\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-structure#:~:text=All%20apps%20created%20with%20Shopify,depending%20on%20your%20app%27s%20functionality) [\[37\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-structure#:~:text=File%2Fdirectory%20Required%3FDescription%20shopify,project%20structure%20or%20template%2C%20you) [\[38\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-structure#:~:text=Web%20files%20directory%20No%20The,such%20as%20a%20responsive%20layout) [\[39\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-structure#:~:text=,the%20name%20of%20the%20directory) [\[40\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-structure#:~:text=%E2%94%94%E2%94%80%E2%94%80%20) [\[41\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-structure#:~:text=%E2%94%9C%E2%94%80%E2%94%80%20extensions%2F) App structure

<https://shopify.dev/docs/apps/build/cli-for-apps/app-structure>

[\[43\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-configuration#:~:text=You%20can%20configure%20your%20apps,active%20version%20of%20your%20app) [\[44\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-configuration#:~:text=Note) [\[45\]](https://shopify.dev/docs/apps/build/cli-for-apps/app-configuration#:~:text=The%20,command) App configuration

<https://shopify.dev/docs/apps/build/cli-for-apps/app-configuration>

[\[46\]](https://shopify.dev/docs/apps/build/cli-for-apps/manage-app-config-files#:~:text=Anchor%20to%20Link%20and%20configure,appsLink%20and%20configure%20apps) [\[47\]](https://shopify.dev/docs/apps/build/cli-for-apps/manage-app-config-files#:~:text=After%20your%20app%20has%20been,development%2C%20staging%2C%20and%20production%20workflows) [\[48\]](https://shopify.dev/docs/apps/build/cli-for-apps/manage-app-config-files#:~:text=You%20don%E2%80%99t%20need%20to%20commit,s%29%20to%20your%20repository) [\[49\]](https://shopify.dev/docs/apps/build/cli-for-apps/manage-app-config-files#:~:text=Anchor%20to%20Test%20your%20app,functionalityTest%20your%20app%20functionality) [\[50\]](https://shopify.dev/docs/apps/build/cli-for-apps/manage-app-config-files#:~:text=Use%20,Learn%20more%20about%20configuration%20names) [\[51\]](https://shopify.dev/docs/apps/build/cli-for-apps/manage-app-config-files#:~:text=You%20can%20create%2C%20link%2C%20and,root%20directory%20of%20your%20app) [\[52\]](https://shopify.dev/docs/apps/build/cli-for-apps/manage-app-config-files#:~:text=shopify%20app%20config%20link) Manage app config files

<https://shopify.dev/docs/apps/build/cli-for-apps/manage-app-config-files>

[\[53\]](https://community.shopify.dev/t/allow-setting-port-for-shopify-app-dev-use-localhost/12798#:~:text=Select%20a%20networking%20option%20for,local%20development) [\[54\]](https://community.shopify.dev/t/allow-setting-port-for-shopify-app-dev-use-localhost/12798#:~:text=NickWesselman%20%20May%2019%2C%202025%2C,1%3A56pm%20%204) [\[55\]](https://community.shopify.dev/t/allow-setting-port-for-shopify-app-dev-use-localhost/12798#:~:text=FYI%20in%20the%20latest%20CLI,port%60%20argument) Allow Setting Port for shopify app dev --use-localhost - Shopify CLI and Libraries - Shopify Developer Community Forums

<https://community.shopify.dev/t/allow-setting-port-for-shopify-app-dev-use-localhost/12798>

[\[56\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-from-dashboard#:~:text=If%20you%27ve%20been%20using%20the,instead%20for%20the%20following%20reasons) [\[57\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-from-dashboard#:~:text=Anchor%20to%20Step%201%3A%20Create,1%3A%20Create%20a%20new%20app) [\[58\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-from-dashboard#:~:text=shopify%20app%20config%20link) [\[59\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-from-dashboard#:~:text=You%27ve%20successfully%20moved%20your%20app,app%20version%20to%20app%20users) [\[60\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-from-dashboard#:~:text=,in%20a%20single%20local%20project) Migrate from a Partner Dashboard-managed app to Shopify CLI

<https://shopify.dev/docs/apps/build/cli-for-apps/migrate-from-dashboard>

[\[61\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-to-latest-cli#:~:text=To%20offer%20a%20better%20and,based%20dependencies%20for%20you) [\[62\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-to-latest-cli#:~:text=When%20you%20migrate%20your%20app,improvements%20to%20the%20developer%20experience) [\[63\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-to-latest-cli#:~:text=Anchor%20to%20Simplified%20configuration%20filesSimplified,configuration%20files) [\[64\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-to-latest-cli#:~:text=If%20you%20have%20an%20app,how%20your%20app%20is%20organized) [\[65\]](https://shopify.dev/docs/apps/build/cli-for-apps/migrate-to-latest-cli#:~:text=Shopify%20CLI%203,generate%20new%20app%20extensions%20easily) Migrate to Shopify CLI 3.x

<https://shopify.dev/docs/apps/build/cli-for-apps/migrate-to-latest-cli>

[\[66\]](https://shopify.dev/docs/apps/build/admin#:~:text=The%20primary%20place%20where%20users,to%20your%20app%20in%20Shopify) [\[67\]](https://shopify.dev/docs/apps/build/admin#:~:text=Anchor%20to%20UI%20extensions%20in,adminUI%20extensions%20in%20admin) [\[68\]](https://shopify.dev/docs/apps/build/admin#:~:text=navigation) [\[69\]](https://shopify.dev/docs/apps/build/admin#:~:text=To%20display%20a%20user%20interface,print%20actions%2C%20and%20admin%20blocks) [\[70\]](https://shopify.dev/docs/apps/build/admin#:~:text=Anchor%20to%20Admin%20print%20actionsAdmin,print%20actions) [\[71\]](https://shopify.dev/docs/apps/build/admin#:~:text=Anchor%20to%20Admin%20actionsAdmin%20actions) [\[72\]](https://shopify.dev/docs/apps/build/admin#:~:text=Anchor%20to%20Admin%20blocksAdmin%20blocks) [\[73\]](https://shopify.dev/docs/apps/build/admin#:~:text=Anchor%20to%20Admin%20link%20extensionsAdmin,link%20extensions) [\[74\]](https://shopify.dev/docs/apps/build/admin#:~:text=The%20Shopify%20admin%20is%20where,and%20can%20be%20easily%20found) Apps in admin

<https://shopify.dev/docs/apps/build/admin>

[\[75\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=UI%20extensions%20enable%20you%20to,be%20more%20efficient%20and%20productive) [\[76\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=Anchor%20to%20Admin%20actionsAdmin%20actions) [\[77\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=Anchor%20to%20Admin%20blocksAdmin%20blocks) [\[78\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=Anchor%20to%20Admin%20print%20actionsAdmin,print%20actions) [\[79\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=With%20admin%20blocks%2C%20merchants%20can,actions%20directly%20from%20admin%20blocks) [\[80\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=to%20embed%20workflows%20and%20UX,be%20more%20efficient%20and%20productive) [\[81\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=Admin%20blocks%20are%20built%20with,before%20they%20can%20use%20it) [\[82\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=You%20can%20create%20UI%20extensions,to%20the%20extension%20target%20reference) [\[83\]](https://shopify.dev/docs/apps/build/admin/actions-blocks#:~:text=Admin%20print%20actions%20are%20a,a%20document%20and%20print%20it) About admin UI extensions

<https://shopify.dev/docs/apps/build/admin/actions-blocks>

[\[84\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-action?extension=react#:~:text=This%20guide%20is%20the%20first,trackable%2C%20resolvable%20issues%20on%20products) [\[85\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-action?extension=react#:~:text=In%20this%20tutorial%2C%20you%27ll%20learn,to%20do%20the%20following%20tasks) [\[86\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-action?extension=react#:~:text=shopify%20app%20generate%20extension%20,flavor%20react) [\[87\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-action?extension=react#:~:text=extensions%2Fissue) [\[88\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-action?extension=react#:~:text=,it%20on%20a%20development%20store) Build an admin action UI extension

<http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-action?extension=react>

[\[89\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-block?extension=react#:~:text=So%20far%2C%20you%27ve%20created%20a,created%20issues%20for%20a%20product) [\[90\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-block?extension=react#:~:text=In%20this%20tutorial%2C%20you%27ll%20learn,to%20do%20the%20following%20tasks) [\[91\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-block?extension=react#:~:text=2,new%20admin%20block%20UI%20extension) [\[92\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-block?extension=react#:~:text=shopify%20app%20generate%20extension%20,flavor%20react) [\[93\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-block?extension=react#:~:text=,the%20UI%20extension%27s%20initial%20state) [\[94\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-block?extension=react#:~:text=,on%20the%20product%20details%20page) Build an admin block UI extension

<http://shopify.dev/docs/apps/build/admin/actions-blocks/build-admin-block?extension=react>

[\[95\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-admin-extensions?extension=react#:~:text=At%20this%20point%20in%20the,used%20in%20the%20same%20location) [\[96\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-admin-extensions?extension=react#:~:text=Now%2C%20you%27ll%20modify%20the%20block,issues%20directly%20from%20the%20block) [\[97\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-admin-extensions?extension=react#:~:text=,edit%20or%20create%20a%20resource) [\[98\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-admin-extensions?extension=react#:~:text=action%20form) [\[99\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-admin-extensions?extension=react#:~:text=Anchor%20to%20What%20you%27ll%20learnWhat,you%27ll%20learn) Connect admin UI extensions

<http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-admin-extensions?extension=react>

[\[100\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=So%20far%20you%27ve%20used%20direct,in%20an%20admin%20UI%20extension) [\[101\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=To%20demonstrate%20this%2C%20we%27ll%20build,values%20from%20the%20app%27s%20backend) [\[102\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=Create%20a%20resource%20route%20in,suggested%20issue%20titles%20and%20descriptions) [\[103\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=Now%20that%20your%20app%20has,extension%27s%20title%20and%20description%20fields) [\[104\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=In%20this%20tutorial%2C%20you%27ll%20learn,to%20do%20the%20following%20tasks) [\[105\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=,can%20use%20to%20fetch%20data) [\[176\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react#:~:text=,can%20use%20to%20fetch%20data) Connect UI extensions to your app's backend

<http://shopify.dev/docs/apps/build/admin/actions-blocks/connect-app-backend?extension=react>

[\[106\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/hide-extensions?extension=react#:~:text=So%20far%20you%27ve%20created%20UI,not%20relevant%20to%20the%20target) [\[107\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/hide-extensions?extension=react#:~:text=,not%20relevant%20to%20the%20target) [\[108\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/hide-extensions?extension=react#:~:text=To%20demonstrate%20conditional%20logic%2C%20we%27ll,UI%20extension%20will%20be%20hidden) [\[109\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/hide-extensions?extension=react#:~:text=If%20an%20admin%20block%20isn%27t,component%20of%20your%20UI%20extension) [\[110\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/hide-extensions?extension=react#:~:text=Anchor%20to%20Collapse%20an%20admin,blockCollapse%20an%20admin%20block) [\[111\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/hide-extensions?extension=react#:~:text=should%20be%20visible,admin%20block%20should%20be%20visible) [\[112\]](http://shopify.dev/docs/apps/build/admin/actions-blocks/hide-extensions?extension=react#:~:text=,not%20relevant%20to%20the%20target) Hide admin UI extensions

<http://shopify.dev/docs/apps/build/admin/actions-blocks/hide-extensions?extension=react>

[\[113\]](https://shopify.dev/docs/apps/build/admin/admin-links#:~:text=Anchor%20to%20Migrating%20from%20admin,links%20and%20bulk%20action%20links) [\[114\]](https://shopify.dev/docs/apps/build/admin/admin-links#:~:text=Admin%20link%20extensions%20let%20you,an%20automation%20for%20any%20order) [\[115\]](https://shopify.dev/docs/apps/build/admin/admin-links#:~:text=to%20related%2C%20complex%20workflows%20in,an%20automation%20for%20any%20order) [\[116\]](https://shopify.dev/docs/apps/build/admin/admin-links#:~:text=Admin%20link%20extensions%20dynamically%20append,relevant%20experiences%20in%20your%20app) [\[117\]](https://shopify.dev/docs/apps/build/admin/admin-links#:~:text=Note) About admin link extensions

<https://shopify.dev/docs/apps/build/admin/admin-links>

[\[118\]](https://shopify.dev/docs/apps/build/admin/admin-links/create-admin-links#:~:text=%24) [\[119\]](https://shopify.dev/docs/apps/build/admin/admin-links/create-admin-links#:~:text=) [\[120\]](https://shopify.dev/docs/apps/build/admin/admin-links/create-admin-links#:~:text=,that%20have%20your%20app%20installed) [\[121\]](https://shopify.dev/docs/apps/build/admin/admin-links/create-admin-links#:~:text=target%20%3D%20) Create admin link extensions

<https://shopify.dev/docs/apps/build/admin/admin-links/create-admin-links>

[\[122\]](https://shopify.dev/docs/apps/build/admin/admin-links/migrate-admin-links#:~:text=Anchor%20to%20Step%201%3A%20Import,1%3A%20Import%20existing%20admin%20links) [\[123\]](https://shopify.dev/docs/apps/build/admin/admin-links/migrate-admin-links#:~:text=shopify%20app%20import) [\[124\]](https://shopify.dev/docs/apps/build/admin/admin-links/migrate-admin-links#:~:text=Anchor%20to%20Step%202%3A%20Deploy,2%3A%20Deploy%20your%20link%20extensions) [\[125\]](https://shopify.dev/docs/apps/build/admin/admin-links/migrate-admin-links#:~:text=%24) Migrate to admin link extensions

<https://shopify.dev/docs/apps/build/admin/admin-links/migrate-admin-links>

[\[126\]](https://shopify.dev/docs/apps/build/checkout#:~:text=After%20a%20customer%20adds%20products,information%20before%20placing%20the%20order) [\[127\]](https://shopify.dev/docs/apps/build/checkout#:~:text=To%20extend%20checkout%2C%20apps%20can,the%20contents%20of%20their%20cart) [\[128\]](https://shopify.dev/docs/apps/build/checkout#:~:text=,Payments%20extensions) [\[129\]](https://shopify.dev/docs/apps/build/checkout#:~:text=the%20contents%20of%20their%20cart) [\[130\]](https://shopify.dev/docs/apps/build/checkout#:~:text=There%20are%20various%20types%20of,can%20use%20to%20customize%20checkout) [\[131\]](https://shopify.dev/docs/apps/build/checkout#:~:text=) [\[132\]](https://shopify.dev/docs/apps/build/checkout#:~:text=For%20a%20detailed%20breakdown%20of,options%20for%20customizing%20Shopify%20checkout) [\[133\]](https://shopify.dev/docs/apps/build/checkout#:~:text=or%20features%20such%20as%20One,checkout) [\[134\]](https://shopify.dev/docs/apps/build/checkout#:~:text=,Payments%20extensions) [\[143\]](https://shopify.dev/docs/apps/build/checkout#:~:text=For%20a%20detailed%20breakdown%20of,options%20for%20customizing%20Shopify%20checkout) [\[170\]](https://shopify.dev/docs/apps/build/checkout#:~:text=instructions%20to%20their%20order.%20Client,extension%20to%20customize%20the%20address) [\[171\]](https://shopify.dev/docs/apps/build/checkout#:~:text=instructions%20to%20their%20order.%20Client,and%20the%20GraphQL%20Admin%20API%27s) [\[172\]](https://shopify.dev/docs/apps/build/checkout#:~:text=extension%20to%20validate%20fields%20at,the%20checkout%20footer%20with%20store) [\[173\]](https://shopify.dev/docs/apps/build/checkout#:~:text=extension,and%20the%20GraphQL%20Admin%20API%27s) [\[174\]](https://shopify.dev/docs/apps/build/checkout#:~:text=instructions%20to%20their%20order.%20Client,45) [\[175\]](https://shopify.dev/docs/apps/build/checkout#:~:text=Use%20a%20checkout%20UI%20extension,extension%20to%20customize%20the%20address) [\[177\]](https://shopify.dev/docs/apps/build/checkout#:~:text=extension%20to%20validate%20fields%20at,billing%20address%20forms%20in%20checkout) [\[179\]](https://shopify.dev/docs/apps/build/checkout#:~:text=Anchor%20to%20Checkout%20UI%20extensions,tutorialsCheckout%20UI%20extensions%20tutorials) [\[181\]](https://shopify.dev/docs/apps/build/checkout#:~:text=Anchor%20to%20Shopify%20Functions%20tutorialsShopify,Functions%20tutorials) [\[183\]](https://shopify.dev/docs/apps/build/checkout#:~:text=Pre,44%2015%20Header) [\[199\]](https://shopify.dev/docs/apps/build/checkout#:~:text=Apps%20in%20checkout,Shopify%20checkout%20with%20new) [\[201\]](https://shopify.dev/docs/apps/build/checkout#:~:text=Apps%20in%20checkout%20,Shopify%20checkout%20with%20new) Apps in checkout

<https://shopify.dev/docs/apps/build/checkout>

[\[135\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=You%20can%20build%20functionality%20in,to%20provide%20the%20following%20experiences) [\[136\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=You%20can%20use%20a%20checkout,side%20validation%20at%20checkout) [\[137\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=Anchor%20to%20Server) [\[138\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=By%20validating%20cart%20and%20checkout,them%20from%20proceeding%20through%20checkout) [\[139\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=A%20benefit%20of%20client,efficient%20and%20streamlined%20user%20experience) [\[140\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=You%20can%20use%20Shopify%20Functions,side) [\[155\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=By%20validating%20checkout%20information%20in,18%20from%20making%20a%20purchase) [\[156\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=block%20customers%20under%20the%20age,18%20from%20making%20a%20purchase) [\[157\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=issues%20sooner%2C%20leading%20to%20a,efficient%20and%20streamlined%20user%20experience) [\[158\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=Using%20Shopify%20Functions%20for%20server,carts%20built%20for%20custom%20storefronts) [\[159\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=However%2C%20it%27s%20important%20to%20note,program%20points%20are%20properly%20redeemed) [\[160\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=Follow%20these%20tutorials%20to%20get,with%20building%20validations%20in%20checkout) [\[161\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=Create%20client,according%20to%20the%20merchant%27s%20preferences) [\[162\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=You%20can%20use%20Shopify%20Functions,side) [\[211\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=documentation%20shopify,side%20validations) [\[212\]](https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation#:~:text=documentation%20shopify,side%20validations) About cart and checkout validation

<https://shopify.dev/docs/apps/build/checkout/cart-checkout-validation>

[\[141\]](https://shopify.dev/docs/apps/build/payments#:~:text=Payments%20extensions%20integrate%20with%20the,extensions%20on%20Shopify%27s%20Payments%20Platform) [\[142\]](https://shopify.dev/docs/apps/build/payments#:~:text=There%20are%20five%20types%20of,payments%20extensions) [\[180\]](https://shopify.dev/docs/apps/build/payments#:~:text=,information%2C%20refer%20to%20Payment%20authorization) [\[182\]](https://shopify.dev/docs/apps/build/payments#:~:text=Note) [\[210\]](https://shopify.dev/docs/apps/build/payments#:~:text=,information%2C%20refer%20to%20Payment%20authorization) Extensions for payments

<https://shopify.dev/docs/apps/build/payments>

[\[144\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=Anchor%20to%20RequirementsRequirements) [\[145\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=Terminal) [\[146\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=4,the%20following%20extension%20types) [\[147\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=6,following%20steps) [\[148\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=%24) [\[149\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=To%20get%20started%20with%20checkout,and%20automates%20common%20development%20tasks) [\[150\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=Copy) [\[153\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=The%20following%20is%20a%20lightweight,settings%20on%20checkout%20form%20fields) [\[154\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=Anchor%20to%20Language,writing%20Shopify%20Functions%20in%20Rust) [\[203\]](https://shopify.dev/docs/apps/build/checkout/start-building#:~:text=Start%20building%20for%20checkout%20,Create%20cart) Start building for checkout

<https://shopify.dev/docs/apps/build/checkout/start-building>

[\[151\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=If%20you%20receive%20the%20error,a%20checkout%20session%20for%20you) [\[152\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=%24) [\[163\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=This%20extension%20uses%20the%20%60purchase.checkout.cart,custom%20data%20after%20the%20product) [\[164\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=Anchor%20to%20Set%20up%20an,targetSet%20up%20an%20extension%20target) [\[165\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=In%20your%20checkout%20UI%20extension%27s,section%20with%20the%20following%20information) [\[166\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=Anchor%20to%20Import%20the%20following,resources%20to%20render%20the%20extension) [\[167\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=Anchor%20to%20Reference%20the%20metafield,metafield%20in%20the%20configuration%20file) [\[168\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=Create%20an%20%60,created%20in%20the%20Shopify%20admin) [\[169\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=4,using%20a%20unique%20HTTPS%20URL) [\[185\]](http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react#:~:text=Anchor%20to%20Missing%20checkout%20linkMissing,checkout%20link) Display custom data at checkout

<http://shopify.dev/docs/apps/build/checkout/display-custom-data?extension=react>

[\[178\]](https://shopify.dev/docs/apps/build/checkout/product-offers#:~:text=About%20product%20offers%20,Create%20cart) About product offers - Shopify developer documentation

<https://shopify.dev/docs/apps/build/checkout/product-offers>

[\[184\]](https://www.colorandcode.com/shopify-novelties/shopifys-latest-checkout-extensions#:~:text=Shopify%27s%20Latest%20Checkout%20Extensions%20,time) Shopify's Latest Checkout Extensions - Color and Code

<https://www.colorandcode.com/shopify-novelties/shopifys-latest-checkout-extensions>

[\[186\]](https://shopify.dev/docs/apps/build/accessibility#:~:text=Anchor%20to%20Keyboard%20and%20gesture,controlsKeyboard%20and%20gesture%20controls) [\[187\]](https://shopify.dev/docs/apps/build/accessibility#:~:text=Anchor%20to%20Keyboard%20supportKeyboard%20support) Accessibility best practices for Shopify apps

<https://shopify.dev/docs/apps/build/accessibility>

[\[188\]](https://shopify.dev/docs/apps/build/flow#:~:text=Shopify%20Flow%20is%20an%20app,such%20as%20triggers%20and%20actions) [\[189\]](https://shopify.dev/docs/apps/build/flow#:~:text=Extension%20type%20Description%20Example%20Trigger,account%20that%20placed%20the%20order) [\[190\]](https://shopify.dev/docs/apps/build/flow#:~:text=Anchor%20to%20Why%20build%20for,FlowWhy%20build%20for%20Flow) [\[191\]](https://shopify.dev/docs/apps/build/flow#:~:text=Extension%20type%20Description%20Example%20Trigger,00%2C%20then) [\[192\]](https://shopify.dev/docs/apps/build/flow#:~:text=Building%20for%20Flow%20can%20help,integrating%20with%20Flow%2C%20you%20can) [\[193\]](https://shopify.dev/docs/apps/build/flow#:~:text=have%20a%20review%20app,integrating%20with%20Flow%2C%20you%20can) [\[194\]](https://shopify.dev/docs/apps/build/flow#:~:text=,the%20%2026%20Flow%20app) [\[195\]](https://shopify.dev/docs/apps/build/flow#:~:text=similar%20value%20to%20your%20merchants,the%20%2026%20Flow%20app) [\[196\]](https://shopify.dev/docs/apps/build/flow#:~:text=total%20amount%20paid%20for%20the,account%20that%20placed%20the%20order) [\[197\]](https://shopify.dev/docs/apps/build/flow#:~:text=Anchor%20to%20TemplatesTemplates) [\[198\]](https://shopify.dev/docs/apps/build/flow#:~:text=A%20template%20in%20Shopify%20Flow,and%20help%20merchants%20do%20more) About Flow

<https://shopify.dev/docs/apps/build/flow>

[\[200\]](https://shopify.dev/docs/apps/build/checkout/styling#:~:text=About%20checkout%20styling%20,Create%20cart) About checkout styling - Shopify developer documentation

<https://shopify.dev/docs/apps/build/checkout/styling>

[\[202\]](https://community.shopify.com/c/shopify-apps/can-you-create-and-run-multiple-extensions-for-one-app/td-p/1945438#:~:text=Display%20multiple%20apps%20in%20checkout,) Can you create and run multiple extensions for one app?

<https://community.shopify.com/c/shopify-apps/can-you-create-and-run-multiple-extensions-for-one-app/td-p/1945438>

[\[204\]](https://shopify.dev/docs/apps/build/functions#:~:text=About%20Shopify%20Functions) [\[205\]](https://shopify.dev/docs/apps/build/functions#:~:text=Shopify%20Functions%20allow%20developers%20to,benefits%20of%20using%20Shopify%20Functions) [\[206\]](https://shopify.dev/docs/apps/build/functions#:~:text=Function%20extension%20targets%20inject%20code,configured%20for%20an%20extension%20target) [\[207\]](https://shopify.dev/docs/apps/build/functions#:~:text=,Rust%20%20and%20%2036) [\[208\]](https://shopify.dev/docs/apps/build/functions#:~:text=Anchor%20to%20How%20Shopify%20Functions,workHow%20Shopify%20Functions%20work) [\[209\]](https://shopify.dev/docs/apps/build/functions#:~:text=specific%20data%20you%20need%20for,line%20product%20data%20or%20metafields) About Shopify Functions

<https://shopify.dev/docs/apps/build/functions>

[\[213\]](https://shopify.dev/docs/api/functions/unstable/cart-and-checkout-validation#:~:text=Cart%20and%20Checkout%20Validation%20Function,to%20proceed%20with%20their) Cart and Checkout Validation Function API - Shopify.dev

<https://shopify.dev/docs/api/functions/unstable/cart-and-checkout-validation>

[\[214\]](https://shopify.dev/docs/api/functions/latest/cart-and-checkout-validation#:~:text=Cart%20and%20checkout%20validation%20implements,to%20proceed%20with%20their%20purchase) Cart and Checkout Validation Function API

<https://shopify.dev/docs/api/functions/latest/cart-and-checkout-validation>

[\[215\]](https://community.shopify.com/t/checkout-validation/303210#:~:text=Community%20community,p%2F2488249) Checkout validation - Functions - Shopify Ecommerce Community

<https://community.shopify.com/t/checkout-validation/303210>